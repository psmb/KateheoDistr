!function (e, t) {if ("object" == typeof exports && "object" == typeof module) module.exports = t(); else if ("function" == typeof define && define.amd) define([], t); else {var n = t(); for (var i in n) ("object" == typeof exports ? exports : e)[i] = n[i]} }(this, function () {return function (e) {function t(i) {if (n[i]) return n[i].exports; var o = n[i] = {exports: {}, id: i, loaded: !1}; return e[i].call(o.exports, o, o.exports, t), o.loaded = !0, o.exports} var n = {}; return t.m = e, t.c = n, t.p = "", t(0)}([function (e, t, n) {e.exports = n(1)}, function (e, t, n) {"use strict"; function i(e) {return e && e.__esModule ? e : {"default": e}} function o(e, t) {function n(e, t) {var n = z, i = n.classNameActiveSlide; e.forEach(function (e, t) {e.classList.contains(i) && e.classList.remove(i)}), e[t].classList.add(i)} function i(e) {var t = z, n = t.infinite, i = e.slice(0, n), o = e.slice(e.length - n, e.length); return i.forEach(function (e) {var t = e.cloneNode(!0); B.appendChild(t)}), o.reverse().forEach(function (e) {var t = e.cloneNode(!0); B.insertBefore(t, B.firstChild)}), B.addEventListener(O.transitionEnd, y), f.call(B.children)} function o(t, n, i) {(0, l["default"])(e, t + ".lory." + n, i)} function a(e, t, n) {var i = B && B.style; i && (i[O.transition + "TimingFunction"] = n, i[O.transition + "Duration"] = t + "ms", O.hasTranslate3d ? i[O.transform] = "translate3d(" + e + "px, 0, 0)" : i[O.transform] = "translate(" + e + "px, 0)")} function d(e, t) {var i = z, r = i.slideSpeed, s = i.slidesToScroll, d = i.infinite, l = i.rewind, c = i.rewindSpeed, u = i.ease, v = i.classNameActiveSlide, m = r, p = t ? P + 1 : P - 1, h = Math.round(M - S); o("before", "slide", {index: P, nextSlide: p}), "number" != typeof e && (e = t ? P + s : P - s), e = Math.min(Math.max(e, 0), _.length - 1), d && void 0 === t && (e += d); var E = Math.min(Math.max(_[e].offsetLeft * -1, h * -1), 0); l && Math.abs(N.x) === h && t && (E = 0, e = 0, m = c), a(E, m, u), N.x = E, _[e].offsetLeft <= h && (P = e), !d || e !== _.length - d && 0 !== e || (t && (P = d), t || (P = _.length - 2 * d), N.x = _[P].offsetLeft * -1, A = function () {a(_[P].offsetLeft * -1, 0, void 0)}), v && n(f.call(_), P), o("after", "slide", {currentSlide: P})} function c() {o("before", "init"), O = (0, s["default"])(), z = r({}, u["default"], t); var a = z, d = a.classNameFrame, l = a.classNameSlideContainer, c = a.classNamePrevCtrl, m = a.classNameNextCtrl, p = a.enableMouseEvents, b = a.classNameActiveSlide; j = e.getElementsByClassName(d)[0], B = j.getElementsByClassName(l)[0], k = e.getElementsByClassName(c)[0], T = e.getElementsByClassName(m)[0], N = {x: B.offsetLeft, y: B.offsetTop}, _ = z.infinite ? i(f.call(B.children)) : f.call(B.children), v(), b && n(_, P), k && T && (k.addEventListener("click", h), T.addEventListener("click", E)), j.addEventListener("touchstart", x), p && (j.addEventListener("mousedown", x), j.addEventListener("click", g)), z.window.addEventListener("resize", C), o("after", "init")} function v() {var e = z, t = e.infinite, i = e.ease, o = e.rewindSpeed, r = e.rewindOnResize, s = e.classNameActiveSlide; M = B.getBoundingClientRect().width || B.offsetWidth, S = j.getBoundingClientRect().width || j.offsetWidth, S === M && (M = _.reduce(function (e, t) {return e + t.getBoundingClientRect().width || t.offsetWidth}, 0)), r ? P = 0 : (i = null, o = 0), t ? (a(_[P + t].offsetLeft * -1, 0, null), P += t, N.x = _[P].offsetLeft * -1) : (a(_[P].offsetLeft * -1, o, i), N.x = _[P].offsetLeft * -1), s && n(f.call(_), P)} function m(e) {d(e)} function p() {return P - z.infinite || 0} function h() {d(!1, !1)} function E() {d(!1, !0)} function b() {o("before", "destroy"), j.removeEventListener(O.transitionEnd, y), j.removeEventListener("touchstart", x), j.removeEventListener("touchmove", L), j.removeEventListener("touchend", w), j.removeEventListener("mousemove", L), j.removeEventListener("mousedown", x), j.removeEventListener("mouseup", w), j.removeEventListener("mouseleave", w), j.removeEventListener("click", g), z.window.removeEventListener("resize", C), k && k.removeEventListener("click", h), T && T.removeEventListener("click", E), z.infinite && Array.apply(null, Array(z.infinite)).forEach(function () {B.removeChild(B.firstChild), B.removeChild(B.lastChild)}), o("after", "destroy")} function y() {A && (A(), A = void 0)} function x(e) {var t = z, n = t.enableMouseEvents, i = e.touches ? e.touches[0] : e; n && (j.addEventListener("mousemove", L), j.addEventListener("mouseup", w), j.addEventListener("mouseleave", w)), j.addEventListener("touchmove", L), j.addEventListener("touchend", w); var r = i.pageX, a = i.pageY; D = {x: r, y: a, time: Date.now()}, F = void 0, R = {}, o("on", "touchstart", {event: e})} function L(e) {var t = e.touches ? e.touches[0] : e, n = t.pageX, i = t.pageY; R = {x: n - D.x, y: i - D.y}, "undefined" == typeof F && (F = !!(F || Math.abs(R.x) < Math.abs(R.y))), !F && D && (e.preventDefault(), a(N.x + R.x, 0, null)), o("on", "touchmove", {event: e})} function w(e) {var t = D ? Date.now() - D.time : void 0, n = Number(t) < 300 && Math.abs(R.x) > 25 || Math.abs(R.x) > S / 3, i = !P && R.x > 0 || P === _.length - 1 && R.x < 0, r = R.x < 0; F || (n && !i ? d(!1, r) : a(N.x, z.snapBackSpeed)), D = void 0, j.removeEventListener("touchmove", L), j.removeEventListener("touchend", w), j.removeEventListener("mousemove", L), j.removeEventListener("mouseup", w), j.removeEventListener("mouseleave", w), o("on", "touchend", {event: e})} function g(e) {R.x && e.preventDefault()} function C(e) {v(), o("on", "resize", {event: e})} var N = void 0, M = void 0, S = void 0, _ = void 0, j = void 0, B = void 0, k = void 0, T = void 0, O = void 0, A = void 0, P = 0, z = {}; "undefined" != typeof jQuery && e instanceof jQuery && (e = e[0]); var D = void 0, R = void 0, F = void 0; return c(), {setup: c, reset: v, slideTo: m, returnIndex: p, prev: h, next: E, destroy: b}} Object.defineProperty(t, "__esModule", {value: !0}); var r = Object.assign || function (e) {for (var t = 1; t < arguments.length; t++) {var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])} return e}; t.lory = o; var a = n(2), s = i(a), d = n(3), l = i(d), c = n(5), u = i(c), f = Array.prototype.slice}, function (e, t) {(function (e) {"use strict"; function n() {var t = void 0, n = void 0, i = void 0, o = void 0; return function () {var r = document.createElement("_"), a = r.style, s = void 0; "" === a[s = "webkitTransition"] && (i = "webkitTransitionEnd", n = s), "" === a[s = "transition"] && (i = "transitionend", n = s), "" === a[s = "webkitTransform"] && (t = s), "" === a[s = "msTransform"] && (t = s), "" === a[s = "transform"] && (t = s), document.body.insertBefore(r, null), a[t] = "translate3d(0, 0, 0)", o = !!e.getComputedStyle(r).getPropertyValue(t), document.body.removeChild(r)}(), {transform: t, transition: n, transitionEnd: i, hasTranslate3d: o}} Object.defineProperty(t, "__esModule", {value: !0}), t["default"] = n}).call(t, function () {return this}())}, function (e, t, n) {"use strict"; function i(e) {return e && e.__esModule ? e : {"default": e}} function o(e, t, n) {var i = new a["default"](t, {bubbles: !0, cancelable: !0, detail: n}); e.dispatchEvent(i)} Object.defineProperty(t, "__esModule", {value: !0}), t["default"] = o; var r = n(4), a = i(r)}, function (e, t) {(function (t) {function n() {try {var e = new i("cat", {detail: {foo: "bar"}}); return "cat" === e.type && "bar" === e.detail.foo} catch (t) {} return !1} var i = t.CustomEvent; e.exports = n() ? i : "function" == typeof document.createEvent ? function (e, t) {var n = document.createEvent("CustomEvent"); return t ? n.initCustomEvent(e, t.bubbles, t.cancelable, t.detail) : n.initCustomEvent(e, !1, !1, void 0), n} : function (e, t) {var n = document.createEventObject(); return n.type = e, t ? (n.bubbles = Boolean(t.bubbles), n.cancelable = Boolean(t.cancelable), n.detail = t.detail) : (n.bubbles = !1, n.cancelable = !1, n.detail = void 0), n}}).call(t, function () {return this}())}, function (e, t) {"use strict"; Object.defineProperty(t, "__esModule", {value: !0}), t["default"] = {slidesToScroll: 1, slideSpeed: 300, rewindSpeed: 600, snapBackSpeed: 200, ease: "ease", rewind: !1, infinite: !1, classNameFrame: "js_frame", classNameSlideContainer: "js_slides", classNamePrevCtrl: "js_prev", classNameNextCtrl: "js_next", classNameActiveSlide: "active", enableMouseEvents: !1, window: window, rewindOnResize: !0}}])});

(function () {

    function Carousel(el) {
        var instance = lory(el, {
            infinite: 1,
            enableMouseEvents: true
        });
    }

    // Shuffle Carousel
    [].slice.call(document.querySelectorAll('[data-carousel]')).forEach(function (el) {
        var ul = el.querySelector('ul');
        for (var i = ul.children.length; i >= 0; i--) {
            ul.appendChild(ul.children[Math.random() * i | 0]);
        }
        Carousel(el);
    });
})();

/**
 * sticky-sidebar - A JavaScript plugin for making smart and high performance.
 * @version v3.3.1
 * @link https://github.com/abouolia/sticky-sidebar
 * @author Ahmed Bouhuolia
 * @license The MIT License (MIT)
**/
!function (t, e) {"object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e(t.StickySidebar = {})}(this, function (t) {"use strict"; "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self && self; var e, i, n = (function (t, e) {(function (t) {Object.defineProperty(t, "__esModule", {value: !0}); var l, n, e = function () {function n(t, e) {for (var i = 0; i < e.length; i++) {var n = e[i]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)} } return function (t, e, i) {return e && n(t.prototype, e), i && n(t, i), t}}(), i = (l = ".stickySidebar", n = {topSpacing: 0, bottomSpacing: 0, containerSelector: !1, innerWrapperSelector: ".inner-wrapper-sticky", stickyClass: "is-affixed", resizeSensor: !0, minWidth: !1}, function () {function c(t) {var e = this, i = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}; if (function (t, e) {if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")}(this, c), this.options = c.extend(n, i), this.sidebar = "string" == typeof t ? document.querySelector(t) : t, void 0 === this.sidebar) throw new Error("There is no specific sidebar element."); this.sidebarInner = !1, this.container = this.sidebar.parentElement, this.affixedType = "STATIC", this.direction = "down", this.support = {transform: !1, transform3d: !1}, this._initialized = !1, this._reStyle = !1, this._breakpoint = !1, this.dimensions = {translateY: 0, maxTranslateY: 0, topSpacing: 0, lastTopSpacing: 0, bottomSpacing: 0, lastBottomSpacing: 0, sidebarHeight: 0, sidebarWidth: 0, containerTop: 0, containerHeight: 0, viewportHeight: 0, viewportTop: 0, lastViewportTop: 0}, ["handleEvent"].forEach(function (t) {e[t] = e[t].bind(e)}), this.initialize()} return e(c, [{key: "initialize", value: function () {var i = this; if (this._setSupportFeatures(), this.options.innerWrapperSelector && (this.sidebarInner = this.sidebar.querySelector(this.options.innerWrapperSelector), null === this.sidebarInner && (this.sidebarInner = !1)), !this.sidebarInner) {var t = document.createElement("div"); for (t.setAttribute("class", "inner-wrapper-sticky"), this.sidebar.appendChild(t); this.sidebar.firstChild != t;)t.appendChild(this.sidebar.firstChild); this.sidebarInner = this.sidebar.querySelector(".inner-wrapper-sticky")} if (this.options.containerSelector) {var e = document.querySelectorAll(this.options.containerSelector); if ((e = Array.prototype.slice.call(e)).forEach(function (t, e) {t.contains(i.sidebar) && (i.container = t)}), !e.length) throw new Error("The container does not contains on the sidebar.")} "function" != typeof this.options.topSpacing && (this.options.topSpacing = parseInt(this.options.topSpacing) || 0), "function" != typeof this.options.bottomSpacing && (this.options.bottomSpacing = parseInt(this.options.bottomSpacing) || 0), this._widthBreakpoint(), this.calcDimensions(), this.stickyPosition(), this.bindEvents(), this._initialized = !0}}, {key: "bindEvents", value: function () {window.addEventListener("resize", this, {passive: !0, capture: !1}), window.addEventListener("scroll", this, {passive: !0, capture: !1}), this.sidebar.addEventListener("update" + l, this), this.options.resizeSensor && "undefined" != typeof ResizeSensor && (new ResizeSensor(this.sidebarInner, this.handleEvent), new ResizeSensor(this.container, this.handleEvent))}}, {key: "handleEvent", value: function (t) {this.updateSticky(t)}}, {key: "calcDimensions", value: function () {if (!this._breakpoint) {var t = this.dimensions; t.containerTop = c.offsetRelative(this.container).top, t.containerHeight = this.container.clientHeight, t.containerBottom = t.containerTop + t.containerHeight, t.sidebarHeight = this.sidebarInner.offsetHeight, t.sidebarWidth = this.sidebarInner.offsetWidth, t.viewportHeight = window.innerHeight, t.maxTranslateY = t.containerHeight - t.sidebarHeight, this._calcDimensionsWithScroll()} }}, {key: "_calcDimensionsWithScroll", value: function () {var t = this.dimensions; t.sidebarLeft = c.offsetRelative(this.sidebar).left, t.viewportTop = document.documentElement.scrollTop || document.body.scrollTop, t.viewportBottom = t.viewportTop + t.viewportHeight, t.viewportLeft = document.documentElement.scrollLeft || document.body.scrollLeft, t.topSpacing = this.options.topSpacing, t.bottomSpacing = this.options.bottomSpacing, "function" == typeof t.topSpacing && (t.topSpacing = parseInt(t.topSpacing(this.sidebar)) || 0), "function" == typeof t.bottomSpacing && (t.bottomSpacing = parseInt(t.bottomSpacing(this.sidebar)) || 0), "VIEWPORT-TOP" === this.affixedType ? t.topSpacing < t.lastTopSpacing && (t.translateY += t.lastTopSpacing - t.topSpacing, this._reStyle = !0) : "VIEWPORT-BOTTOM" === this.affixedType && t.bottomSpacing < t.lastBottomSpacing && (t.translateY += t.lastBottomSpacing - t.bottomSpacing, this._reStyle = !0), t.lastTopSpacing = t.topSpacing, t.lastBottomSpacing = t.bottomSpacing}}, {key: "isSidebarFitsViewport", value: function () {var t = this.dimensions, e = "down" === this.scrollDirection ? t.lastBottomSpacing : t.lastTopSpacing; return this.dimensions.sidebarHeight + e < this.dimensions.viewportHeight}}, {key: "observeScrollDir", value: function () {var t = this.dimensions; if (t.lastViewportTop !== t.viewportTop) {var e = "down" === this.direction ? Math.min : Math.max; t.viewportTop === e(t.viewportTop, t.lastViewportTop) && (this.direction = "down" === this.direction ? "up" : "down")} }}, {key: "getAffixType", value: function () {this._calcDimensionsWithScroll(); var t = this.dimensions, e = t.viewportTop + t.topSpacing, i = this.affixedType; return e <= t.containerTop || t.containerHeight <= t.sidebarHeight ? (t.translateY = 0, i = "STATIC") : i = "up" === this.direction ? this._getAffixTypeScrollingUp() : this._getAffixTypeScrollingDown(), t.translateY = Math.max(0, t.translateY), t.translateY = Math.min(t.containerHeight, t.translateY), t.translateY = Math.round(t.translateY), t.lastViewportTop = t.viewportTop, i}}, {key: "_getAffixTypeScrollingDown", value: function () {var t = this.dimensions, e = t.sidebarHeight + t.containerTop, i = t.viewportTop + t.topSpacing, n = t.viewportBottom - t.bottomSpacing, o = this.affixedType; return this.isSidebarFitsViewport() ? t.sidebarHeight + i >= t.containerBottom ? (t.translateY = t.containerBottom - e, o = "CONTAINER-BOTTOM") : i >= t.containerTop && (t.translateY = i - t.containerTop, o = "VIEWPORT-TOP") : t.containerBottom <= n ? (t.translateY = t.containerBottom - e, o = "CONTAINER-BOTTOM") : e + t.translateY <= n ? (t.translateY = n - e, o = "VIEWPORT-BOTTOM") : t.containerTop + t.translateY <= i && 0 !== t.translateY && t.maxTranslateY !== t.translateY && (o = "VIEWPORT-UNBOTTOM"), o}}, {key: "_getAffixTypeScrollingUp", value: function () {var t = this.dimensions, e = t.sidebarHeight + t.containerTop, i = t.viewportTop + t.topSpacing, n = t.viewportBottom - t.bottomSpacing, o = this.affixedType; return i <= t.translateY + t.containerTop ? (t.translateY = i - t.containerTop, o = "VIEWPORT-TOP") : t.containerBottom <= n ? (t.translateY = t.containerBottom - e, o = "CONTAINER-BOTTOM") : this.isSidebarFitsViewport() || t.containerTop <= i && 0 !== t.translateY && t.maxTranslateY !== t.translateY && (o = "VIEWPORT-UNBOTTOM"), o}}, {key: "_getStyle", value: function (t) {if (void 0 !== t) {var e = {inner: {}, outer: {}}, i = this.dimensions; switch (t) {case "VIEWPORT-TOP": e.inner = {position: "fixed", top: i.topSpacing, left: i.sidebarLeft - i.viewportLeft, width: i.sidebarWidth}; break; case "VIEWPORT-BOTTOM": e.inner = {position: "fixed", top: "auto", left: i.sidebarLeft, bottom: i.bottomSpacing, width: i.sidebarWidth}; break; case "CONTAINER-BOTTOM": case "VIEWPORT-UNBOTTOM": var n = this._getTranslate(0, i.translateY + "px"); e.inner = n ? {transform: n} : {position: "absolute", top: i.translateY, width: i.sidebarWidth}}switch (t) {case "VIEWPORT-TOP": case "VIEWPORT-BOTTOM": case "VIEWPORT-UNBOTTOM": case "CONTAINER-BOTTOM": e.outer = {height: i.sidebarHeight, position: "relative"}}return e.outer = c.extend({height: "", position: ""}, e.outer), e.inner = c.extend({position: "relative", top: "", left: "", bottom: "", width: "", transform: ""}, e.inner), e} }}, {key: "stickyPosition", value: function (t) {if (!this._breakpoint) {t = this._reStyle || t || !1, this.options.topSpacing, this.options.bottomSpacing; var e = this.getAffixType(), i = this._getStyle(e); if ((this.affixedType != e || t) && e) {var n = "affix." + e.toLowerCase().replace("viewport-", "") + l; for (var o in c.eventTrigger(this.sidebar, n), "STATIC" === e ? c.removeClass(this.sidebar, this.options.stickyClass) : c.addClass(this.sidebar, this.options.stickyClass), i.outer) {var s = "number" == typeof i.outer[o] ? "px" : ""; this.sidebar.style[o] = i.outer[o] + s} for (var r in i.inner) {var a = "number" == typeof i.inner[r] ? "px" : ""; this.sidebarInner.style[r] = i.inner[r] + a} var p = "affixed." + e.toLowerCase().replace("viewport-", "") + l; c.eventTrigger(this.sidebar, p)} else this._initialized && (this.sidebarInner.style.left = i.inner.left); this.affixedType = e} }}, {key: "_widthBreakpoint", value: function () {window.innerWidth <= this.options.minWidth ? (this._breakpoint = !0, this.affixedType = "STATIC", this.sidebar.removeAttribute("style"), c.removeClass(this.sidebar, this.options.stickyClass), this.sidebarInner.removeAttribute("style")) : this._breakpoint = !1}}, {key: "updateSticky", value: function () {var t, e = this, i = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {}; this._running || (this._running = !0, t = i.type, requestAnimationFrame(function () {switch (t) {case "scroll": e._calcDimensionsWithScroll(), e.observeScrollDir(), e.stickyPosition(); break; case "resize": default: e._widthBreakpoint(), e.calcDimensions(), e.stickyPosition(!0)}e._running = !1}))}}, {key: "_setSupportFeatures", value: function () {var t = this.support; t.transform = c.supportTransform(), t.transform3d = c.supportTransform(!0)}}, {key: "_getTranslate", value: function () {var t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0; return this.support.transform3d ? "translate3d(" + t + ", " + e + ", " + i + ")" : !!this.support.translate && "translate(" + t + ", " + e + ")"}}, {key: "destroy", value: function () {window.removeEventListener("resize", this, {capture: !1}), window.removeEventListener("scroll", this, {capture: !1}), this.sidebar.classList.remove(this.options.stickyClass), this.sidebar.style.minHeight = "", this.sidebar.removeEventListener("update" + l, this); var t = {inner: {}, outer: {}}; for (var e in t.inner = {position: "", top: "", left: "", bottom: "", width: "", transform: ""}, t.outer = {height: "", position: ""}, t.outer) this.sidebar.style[e] = t.outer[e]; for (var i in t.inner) this.sidebarInner.style[i] = t.inner[i]; this.options.resizeSensor && "undefined" != typeof ResizeSensor && (ResizeSensor.detach(this.sidebarInner, this.handleEvent), ResizeSensor.detach(this.container, this.handleEvent))}}], [{key: "supportTransform", value: function (t) {var i = !1, e = t ? "perspective" : "transform", n = e.charAt(0).toUpperCase() + e.slice(1), o = document.createElement("support").style; return (e + " " + ["Webkit", "Moz", "O", "ms"].join(n + " ") + n).split(" ").forEach(function (t, e) {if (void 0 !== o[t]) return i = t, !1}), i}}, {key: "eventTrigger", value: function (t, e, i) {try {var n = new CustomEvent(e, {detail: i})} catch (t) {(n = document.createEvent("CustomEvent")).initCustomEvent(e, !0, !0, i)} t.dispatchEvent(n)}}, {key: "extend", value: function (t, e) {var i = {}; for (var n in t) void 0 !== e[n] ? i[n] = e[n] : i[n] = t[n]; return i}}, {key: "offsetRelative", value: function (t) {var e = {left: 0, top: 0}; do {var i = t.offsetTop, n = t.offsetLeft; isNaN(i) || (e.top += i), isNaN(n) || (e.left += n), t = "BODY" === t.tagName ? t.parentElement : t.offsetParent} while (t); return e}}, {key: "addClass", value: function (t, e) {c.hasClass(t, e) || (t.classList ? t.classList.add(e) : t.className += " " + e)}}, {key: "removeClass", value: function (t, e) {c.hasClass(t, e) && (t.classList ? t.classList.remove(e) : t.className = t.className.replace(new RegExp("(^|\\b)" + e.split(" ").join("|") + "(\\b|$)", "gi"), " "))}}, {key: "hasClass", value: function (t, e) {return t.classList ? t.classList.contains(e) : new RegExp("(^| )" + e + "( |$)", "gi").test(t.className)}}, {key: "defaults", get: function () {return n}}]), c}()); t.default = i, window.StickySidebar = i})(e)}(e = {exports: {}}, e.exports), e.exports), o = (i = n) && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i; t.default = o, t.__moduleExports = n, Object.defineProperty(t, "__esModule", {value: !0})});

if (document.querySelector('.js-sticky-sidebar')) {
    var sidebar = new StickySidebar('.js-sticky-sidebar', {
        topSpacing: 20,
        bottomSpacing: 20,
        containerSelector: '.js-sticky-main-content',
        innerWrapperSelector: '.js-sticky-sidebar__inner',
        minWidth: 1024
    });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInZlbmRvci1sb3J5LmpzIiwidmVuZG9yLXN0aWNreS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24gKGUsIHQpIHtpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZXhwb3J0cyAmJiBcIm9iamVjdFwiID09IHR5cGVvZiBtb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gdCgpOyBlbHNlIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kKSBkZWZpbmUoW10sIHQpOyBlbHNlIHt2YXIgbiA9IHQoKTsgZm9yICh2YXIgaSBpbiBuKSAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZXhwb3J0cyA/IGV4cG9ydHMgOiBlKVtpXSA9IG5baV19IH0odGhpcywgZnVuY3Rpb24gKCkge3JldHVybiBmdW5jdGlvbiAoZSkge2Z1bmN0aW9uIHQoaSkge2lmIChuW2ldKSByZXR1cm4gbltpXS5leHBvcnRzOyB2YXIgbyA9IG5baV0gPSB7ZXhwb3J0czoge30sIGlkOiBpLCBsb2FkZWQ6ICExfTsgcmV0dXJuIGVbaV0uY2FsbChvLmV4cG9ydHMsIG8sIG8uZXhwb3J0cywgdCksIG8ubG9hZGVkID0gITAsIG8uZXhwb3J0c30gdmFyIG4gPSB7fTsgcmV0dXJuIHQubSA9IGUsIHQuYyA9IG4sIHQucCA9IFwiXCIsIHQoMCl9KFtmdW5jdGlvbiAoZSwgdCwgbikge2UuZXhwb3J0cyA9IG4oMSl9LCBmdW5jdGlvbiAoZSwgdCwgbikge1widXNlIHN0cmljdFwiOyBmdW5jdGlvbiBpKGUpIHtyZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDoge1wiZGVmYXVsdFwiOiBlfX0gZnVuY3Rpb24gbyhlLCB0KSB7ZnVuY3Rpb24gbihlLCB0KSB7dmFyIG4gPSB6LCBpID0gbi5jbGFzc05hbWVBY3RpdmVTbGlkZTsgZS5mb3JFYWNoKGZ1bmN0aW9uIChlLCB0KSB7ZS5jbGFzc0xpc3QuY29udGFpbnMoaSkgJiYgZS5jbGFzc0xpc3QucmVtb3ZlKGkpfSksIGVbdF0uY2xhc3NMaXN0LmFkZChpKX0gZnVuY3Rpb24gaShlKSB7dmFyIHQgPSB6LCBuID0gdC5pbmZpbml0ZSwgaSA9IGUuc2xpY2UoMCwgbiksIG8gPSBlLnNsaWNlKGUubGVuZ3RoIC0gbiwgZS5sZW5ndGgpOyByZXR1cm4gaS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7dmFyIHQgPSBlLmNsb25lTm9kZSghMCk7IEIuYXBwZW5kQ2hpbGQodCl9KSwgby5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbiAoZSkge3ZhciB0ID0gZS5jbG9uZU5vZGUoITApOyBCLmluc2VydEJlZm9yZSh0LCBCLmZpcnN0Q2hpbGQpfSksIEIuYWRkRXZlbnRMaXN0ZW5lcihPLnRyYW5zaXRpb25FbmQsIHkpLCBmLmNhbGwoQi5jaGlsZHJlbil9IGZ1bmN0aW9uIG8odCwgbiwgaSkgeygwLCBsW1wiZGVmYXVsdFwiXSkoZSwgdCArIFwiLmxvcnkuXCIgKyBuLCBpKX0gZnVuY3Rpb24gYShlLCB0LCBuKSB7dmFyIGkgPSBCICYmIEIuc3R5bGU7IGkgJiYgKGlbTy50cmFuc2l0aW9uICsgXCJUaW1pbmdGdW5jdGlvblwiXSA9IG4sIGlbTy50cmFuc2l0aW9uICsgXCJEdXJhdGlvblwiXSA9IHQgKyBcIm1zXCIsIE8uaGFzVHJhbnNsYXRlM2QgPyBpW08udHJhbnNmb3JtXSA9IFwidHJhbnNsYXRlM2QoXCIgKyBlICsgXCJweCwgMCwgMClcIiA6IGlbTy50cmFuc2Zvcm1dID0gXCJ0cmFuc2xhdGUoXCIgKyBlICsgXCJweCwgMClcIil9IGZ1bmN0aW9uIGQoZSwgdCkge3ZhciBpID0geiwgciA9IGkuc2xpZGVTcGVlZCwgcyA9IGkuc2xpZGVzVG9TY3JvbGwsIGQgPSBpLmluZmluaXRlLCBsID0gaS5yZXdpbmQsIGMgPSBpLnJld2luZFNwZWVkLCB1ID0gaS5lYXNlLCB2ID0gaS5jbGFzc05hbWVBY3RpdmVTbGlkZSwgbSA9IHIsIHAgPSB0ID8gUCArIDEgOiBQIC0gMSwgaCA9IE1hdGgucm91bmQoTSAtIFMpOyBvKFwiYmVmb3JlXCIsIFwic2xpZGVcIiwge2luZGV4OiBQLCBuZXh0U2xpZGU6IHB9KSwgXCJudW1iZXJcIiAhPSB0eXBlb2YgZSAmJiAoZSA9IHQgPyBQICsgcyA6IFAgLSBzKSwgZSA9IE1hdGgubWluKE1hdGgubWF4KGUsIDApLCBfLmxlbmd0aCAtIDEpLCBkICYmIHZvaWQgMCA9PT0gdCAmJiAoZSArPSBkKTsgdmFyIEUgPSBNYXRoLm1pbihNYXRoLm1heChfW2VdLm9mZnNldExlZnQgKiAtMSwgaCAqIC0xKSwgMCk7IGwgJiYgTWF0aC5hYnMoTi54KSA9PT0gaCAmJiB0ICYmIChFID0gMCwgZSA9IDAsIG0gPSBjKSwgYShFLCBtLCB1KSwgTi54ID0gRSwgX1tlXS5vZmZzZXRMZWZ0IDw9IGggJiYgKFAgPSBlKSwgIWQgfHwgZSAhPT0gXy5sZW5ndGggLSBkICYmIDAgIT09IGUgfHwgKHQgJiYgKFAgPSBkKSwgdCB8fCAoUCA9IF8ubGVuZ3RoIC0gMiAqIGQpLCBOLnggPSBfW1BdLm9mZnNldExlZnQgKiAtMSwgQSA9IGZ1bmN0aW9uICgpIHthKF9bUF0ub2Zmc2V0TGVmdCAqIC0xLCAwLCB2b2lkIDApfSksIHYgJiYgbihmLmNhbGwoXyksIFApLCBvKFwiYWZ0ZXJcIiwgXCJzbGlkZVwiLCB7Y3VycmVudFNsaWRlOiBQfSl9IGZ1bmN0aW9uIGMoKSB7byhcImJlZm9yZVwiLCBcImluaXRcIiksIE8gPSAoMCwgc1tcImRlZmF1bHRcIl0pKCksIHogPSByKHt9LCB1W1wiZGVmYXVsdFwiXSwgdCk7IHZhciBhID0geiwgZCA9IGEuY2xhc3NOYW1lRnJhbWUsIGwgPSBhLmNsYXNzTmFtZVNsaWRlQ29udGFpbmVyLCBjID0gYS5jbGFzc05hbWVQcmV2Q3RybCwgbSA9IGEuY2xhc3NOYW1lTmV4dEN0cmwsIHAgPSBhLmVuYWJsZU1vdXNlRXZlbnRzLCBiID0gYS5jbGFzc05hbWVBY3RpdmVTbGlkZTsgaiA9IGUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShkKVswXSwgQiA9IGouZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShsKVswXSwgayA9IGUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjKVswXSwgVCA9IGUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShtKVswXSwgTiA9IHt4OiBCLm9mZnNldExlZnQsIHk6IEIub2Zmc2V0VG9wfSwgXyA9IHouaW5maW5pdGUgPyBpKGYuY2FsbChCLmNoaWxkcmVuKSkgOiBmLmNhbGwoQi5jaGlsZHJlbiksIHYoKSwgYiAmJiBuKF8sIFApLCBrICYmIFQgJiYgKGsuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGgpLCBULmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBFKSksIGouYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgeCksIHAgJiYgKGouYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB4KSwgai5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZykpLCB6LndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIEMpLCBvKFwiYWZ0ZXJcIiwgXCJpbml0XCIpfSBmdW5jdGlvbiB2KCkge3ZhciBlID0geiwgdCA9IGUuaW5maW5pdGUsIGkgPSBlLmVhc2UsIG8gPSBlLnJld2luZFNwZWVkLCByID0gZS5yZXdpbmRPblJlc2l6ZSwgcyA9IGUuY2xhc3NOYW1lQWN0aXZlU2xpZGU7IE0gPSBCLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHx8IEIub2Zmc2V0V2lkdGgsIFMgPSBqLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHx8IGoub2Zmc2V0V2lkdGgsIFMgPT09IE0gJiYgKE0gPSBfLnJlZHVjZShmdW5jdGlvbiAoZSwgdCkge3JldHVybiBlICsgdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB8fCB0Lm9mZnNldFdpZHRofSwgMCkpLCByID8gUCA9IDAgOiAoaSA9IG51bGwsIG8gPSAwKSwgdCA/IChhKF9bUCArIHRdLm9mZnNldExlZnQgKiAtMSwgMCwgbnVsbCksIFAgKz0gdCwgTi54ID0gX1tQXS5vZmZzZXRMZWZ0ICogLTEpIDogKGEoX1tQXS5vZmZzZXRMZWZ0ICogLTEsIG8sIGkpLCBOLnggPSBfW1BdLm9mZnNldExlZnQgKiAtMSksIHMgJiYgbihmLmNhbGwoXyksIFApfSBmdW5jdGlvbiBtKGUpIHtkKGUpfSBmdW5jdGlvbiBwKCkge3JldHVybiBQIC0gei5pbmZpbml0ZSB8fCAwfSBmdW5jdGlvbiBoKCkge2QoITEsICExKX0gZnVuY3Rpb24gRSgpIHtkKCExLCAhMCl9IGZ1bmN0aW9uIGIoKSB7byhcImJlZm9yZVwiLCBcImRlc3Ryb3lcIiksIGoucmVtb3ZlRXZlbnRMaXN0ZW5lcihPLnRyYW5zaXRpb25FbmQsIHkpLCBqLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHgpLCBqLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgTCksIGoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHcpLCBqLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgTCksIGoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB4KSwgai5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB3KSwgai5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB3KSwgai5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZyksIHoud2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgQyksIGsgJiYgay5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaCksIFQgJiYgVC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgRSksIHouaW5maW5pdGUgJiYgQXJyYXkuYXBwbHkobnVsbCwgQXJyYXkoei5pbmZpbml0ZSkpLmZvckVhY2goZnVuY3Rpb24gKCkge0IucmVtb3ZlQ2hpbGQoQi5maXJzdENoaWxkKSwgQi5yZW1vdmVDaGlsZChCLmxhc3RDaGlsZCl9KSwgbyhcImFmdGVyXCIsIFwiZGVzdHJveVwiKX0gZnVuY3Rpb24geSgpIHtBICYmIChBKCksIEEgPSB2b2lkIDApfSBmdW5jdGlvbiB4KGUpIHt2YXIgdCA9IHosIG4gPSB0LmVuYWJsZU1vdXNlRXZlbnRzLCBpID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTsgbiAmJiAoai5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIEwpLCBqLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHcpLCBqLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHcpKSwgai5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIEwpLCBqLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB3KTsgdmFyIHIgPSBpLnBhZ2VYLCBhID0gaS5wYWdlWTsgRCA9IHt4OiByLCB5OiBhLCB0aW1lOiBEYXRlLm5vdygpfSwgRiA9IHZvaWQgMCwgUiA9IHt9LCBvKFwib25cIiwgXCJ0b3VjaHN0YXJ0XCIsIHtldmVudDogZX0pfSBmdW5jdGlvbiBMKGUpIHt2YXIgdCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGUsIG4gPSB0LnBhZ2VYLCBpID0gdC5wYWdlWTsgUiA9IHt4OiBuIC0gRC54LCB5OiBpIC0gRC55fSwgXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgRiAmJiAoRiA9ICEhKEYgfHwgTWF0aC5hYnMoUi54KSA8IE1hdGguYWJzKFIueSkpKSwgIUYgJiYgRCAmJiAoZS5wcmV2ZW50RGVmYXVsdCgpLCBhKE4ueCArIFIueCwgMCwgbnVsbCkpLCBvKFwib25cIiwgXCJ0b3VjaG1vdmVcIiwge2V2ZW50OiBlfSl9IGZ1bmN0aW9uIHcoZSkge3ZhciB0ID0gRCA/IERhdGUubm93KCkgLSBELnRpbWUgOiB2b2lkIDAsIG4gPSBOdW1iZXIodCkgPCAzMDAgJiYgTWF0aC5hYnMoUi54KSA+IDI1IHx8IE1hdGguYWJzKFIueCkgPiBTIC8gMywgaSA9ICFQICYmIFIueCA+IDAgfHwgUCA9PT0gXy5sZW5ndGggLSAxICYmIFIueCA8IDAsIHIgPSBSLnggPCAwOyBGIHx8IChuICYmICFpID8gZCghMSwgcikgOiBhKE4ueCwgei5zbmFwQmFja1NwZWVkKSksIEQgPSB2b2lkIDAsIGoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBMKSwgai5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdyksIGoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBMKSwgai5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB3KSwgai5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB3KSwgbyhcIm9uXCIsIFwidG91Y2hlbmRcIiwge2V2ZW50OiBlfSl9IGZ1bmN0aW9uIGcoZSkge1IueCAmJiBlLnByZXZlbnREZWZhdWx0KCl9IGZ1bmN0aW9uIEMoZSkge3YoKSwgbyhcIm9uXCIsIFwicmVzaXplXCIsIHtldmVudDogZX0pfSB2YXIgTiA9IHZvaWQgMCwgTSA9IHZvaWQgMCwgUyA9IHZvaWQgMCwgXyA9IHZvaWQgMCwgaiA9IHZvaWQgMCwgQiA9IHZvaWQgMCwgayA9IHZvaWQgMCwgVCA9IHZvaWQgMCwgTyA9IHZvaWQgMCwgQSA9IHZvaWQgMCwgUCA9IDAsIHogPSB7fTsgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgalF1ZXJ5ICYmIGUgaW5zdGFuY2VvZiBqUXVlcnkgJiYgKGUgPSBlWzBdKTsgdmFyIEQgPSB2b2lkIDAsIFIgPSB2b2lkIDAsIEYgPSB2b2lkIDA7IHJldHVybiBjKCksIHtzZXR1cDogYywgcmVzZXQ6IHYsIHNsaWRlVG86IG0sIHJldHVybkluZGV4OiBwLCBwcmV2OiBoLCBuZXh0OiBFLCBkZXN0cm95OiBifX0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6ICEwfSk7IHZhciByID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAoZSkge2ZvciAodmFyIHQgPSAxOyB0IDwgYXJndW1lbnRzLmxlbmd0aDsgdCsrKSB7dmFyIG4gPSBhcmd1bWVudHNbdF07IGZvciAodmFyIGkgaW4gbikgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sIGkpICYmIChlW2ldID0gbltpXSl9IHJldHVybiBlfTsgdC5sb3J5ID0gbzsgdmFyIGEgPSBuKDIpLCBzID0gaShhKSwgZCA9IG4oMyksIGwgPSBpKGQpLCBjID0gbig1KSwgdSA9IGkoYyksIGYgPSBBcnJheS5wcm90b3R5cGUuc2xpY2V9LCBmdW5jdGlvbiAoZSwgdCkgeyhmdW5jdGlvbiAoZSkge1widXNlIHN0cmljdFwiOyBmdW5jdGlvbiBuKCkge3ZhciB0ID0gdm9pZCAwLCBuID0gdm9pZCAwLCBpID0gdm9pZCAwLCBvID0gdm9pZCAwOyByZXR1cm4gZnVuY3Rpb24gKCkge3ZhciByID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIl9cIiksIGEgPSByLnN0eWxlLCBzID0gdm9pZCAwOyBcIlwiID09PSBhW3MgPSBcIndlYmtpdFRyYW5zaXRpb25cIl0gJiYgKGkgPSBcIndlYmtpdFRyYW5zaXRpb25FbmRcIiwgbiA9IHMpLCBcIlwiID09PSBhW3MgPSBcInRyYW5zaXRpb25cIl0gJiYgKGkgPSBcInRyYW5zaXRpb25lbmRcIiwgbiA9IHMpLCBcIlwiID09PSBhW3MgPSBcIndlYmtpdFRyYW5zZm9ybVwiXSAmJiAodCA9IHMpLCBcIlwiID09PSBhW3MgPSBcIm1zVHJhbnNmb3JtXCJdICYmICh0ID0gcyksIFwiXCIgPT09IGFbcyA9IFwidHJhbnNmb3JtXCJdICYmICh0ID0gcyksIGRvY3VtZW50LmJvZHkuaW5zZXJ0QmVmb3JlKHIsIG51bGwpLCBhW3RdID0gXCJ0cmFuc2xhdGUzZCgwLCAwLCAwKVwiLCBvID0gISFlLmdldENvbXB1dGVkU3R5bGUocikuZ2V0UHJvcGVydHlWYWx1ZSh0KSwgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChyKX0oKSwge3RyYW5zZm9ybTogdCwgdHJhbnNpdGlvbjogbiwgdHJhbnNpdGlvbkVuZDogaSwgaGFzVHJhbnNsYXRlM2Q6IG99fSBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogITB9KSwgdFtcImRlZmF1bHRcIl0gPSBufSkuY2FsbCh0LCBmdW5jdGlvbiAoKSB7cmV0dXJuIHRoaXN9KCkpfSwgZnVuY3Rpb24gKGUsIHQsIG4pIHtcInVzZSBzdHJpY3RcIjsgZnVuY3Rpb24gaShlKSB7cmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHtcImRlZmF1bHRcIjogZX19IGZ1bmN0aW9uIG8oZSwgdCwgbikge3ZhciBpID0gbmV3IGFbXCJkZWZhdWx0XCJdKHQsIHtidWJibGVzOiAhMCwgY2FuY2VsYWJsZTogITAsIGRldGFpbDogbn0pOyBlLmRpc3BhdGNoRXZlbnQoaSl9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiAhMH0pLCB0W1wiZGVmYXVsdFwiXSA9IG87IHZhciByID0gbig0KSwgYSA9IGkocil9LCBmdW5jdGlvbiAoZSwgdCkgeyhmdW5jdGlvbiAodCkge2Z1bmN0aW9uIG4oKSB7dHJ5IHt2YXIgZSA9IG5ldyBpKFwiY2F0XCIsIHtkZXRhaWw6IHtmb286IFwiYmFyXCJ9fSk7IHJldHVybiBcImNhdFwiID09PSBlLnR5cGUgJiYgXCJiYXJcIiA9PT0gZS5kZXRhaWwuZm9vfSBjYXRjaCAodCkge30gcmV0dXJuICExfSB2YXIgaSA9IHQuQ3VzdG9tRXZlbnQ7IGUuZXhwb3J0cyA9IG4oKSA/IGkgOiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUV2ZW50ID8gZnVuY3Rpb24gKGUsIHQpIHt2YXIgbiA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7IHJldHVybiB0ID8gbi5pbml0Q3VzdG9tRXZlbnQoZSwgdC5idWJibGVzLCB0LmNhbmNlbGFibGUsIHQuZGV0YWlsKSA6IG4uaW5pdEN1c3RvbUV2ZW50KGUsICExLCAhMSwgdm9pZCAwKSwgbn0gOiBmdW5jdGlvbiAoZSwgdCkge3ZhciBuID0gZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKTsgcmV0dXJuIG4udHlwZSA9IGUsIHQgPyAobi5idWJibGVzID0gQm9vbGVhbih0LmJ1YmJsZXMpLCBuLmNhbmNlbGFibGUgPSBCb29sZWFuKHQuY2FuY2VsYWJsZSksIG4uZGV0YWlsID0gdC5kZXRhaWwpIDogKG4uYnViYmxlcyA9ICExLCBuLmNhbmNlbGFibGUgPSAhMSwgbi5kZXRhaWwgPSB2b2lkIDApLCBufX0pLmNhbGwodCwgZnVuY3Rpb24gKCkge3JldHVybiB0aGlzfSgpKX0sIGZ1bmN0aW9uIChlLCB0KSB7XCJ1c2Ugc3RyaWN0XCI7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiAhMH0pLCB0W1wiZGVmYXVsdFwiXSA9IHtzbGlkZXNUb1Njcm9sbDogMSwgc2xpZGVTcGVlZDogMzAwLCByZXdpbmRTcGVlZDogNjAwLCBzbmFwQmFja1NwZWVkOiAyMDAsIGVhc2U6IFwiZWFzZVwiLCByZXdpbmQ6ICExLCBpbmZpbml0ZTogITEsIGNsYXNzTmFtZUZyYW1lOiBcImpzX2ZyYW1lXCIsIGNsYXNzTmFtZVNsaWRlQ29udGFpbmVyOiBcImpzX3NsaWRlc1wiLCBjbGFzc05hbWVQcmV2Q3RybDogXCJqc19wcmV2XCIsIGNsYXNzTmFtZU5leHRDdHJsOiBcImpzX25leHRcIiwgY2xhc3NOYW1lQWN0aXZlU2xpZGU6IFwiYWN0aXZlXCIsIGVuYWJsZU1vdXNlRXZlbnRzOiAhMSwgd2luZG93OiB3aW5kb3csIHJld2luZE9uUmVzaXplOiAhMH19XSl9KTtcblxuKGZ1bmN0aW9uICgpIHtcblxuICAgIGZ1bmN0aW9uIENhcm91c2VsKGVsKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGxvcnkoZWwsIHtcbiAgICAgICAgICAgIGluZmluaXRlOiAxLFxuICAgICAgICAgICAgZW5hYmxlTW91c2VFdmVudHM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gU2h1ZmZsZSBDYXJvdXNlbFxuICAgIFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtY2Fyb3VzZWxdJykpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHZhciB1bCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ3VsJyk7XG4gICAgICAgIGZvciAodmFyIGkgPSB1bC5jaGlsZHJlbi5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB1bC5hcHBlbmRDaGlsZCh1bC5jaGlsZHJlbltNYXRoLnJhbmRvbSgpICogaSB8IDBdKTtcbiAgICAgICAgfVxuICAgICAgICBDYXJvdXNlbChlbCk7XG4gICAgfSk7XG59KSgpO1xuIiwiLyoqXG4gKiBzdGlja3ktc2lkZWJhciAtIEEgSmF2YVNjcmlwdCBwbHVnaW4gZm9yIG1ha2luZyBzbWFydCBhbmQgaGlnaCBwZXJmb3JtYW5jZS5cbiAqIEB2ZXJzaW9uIHYzLjMuMVxuICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Fib3VvbGlhL3N0aWNreS1zaWRlYmFyXG4gKiBAYXV0aG9yIEFobWVkIEJvdWh1b2xpYVxuICogQGxpY2Vuc2UgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4qKi9cbiFmdW5jdGlvbiAodCwgZSkge1wib2JqZWN0XCIgPT0gdHlwZW9mIGV4cG9ydHMgJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgbW9kdWxlID8gZShleHBvcnRzKSA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoW1wiZXhwb3J0c1wiXSwgZSkgOiBlKHQuU3RpY2t5U2lkZWJhciA9IHt9KX0odGhpcywgZnVuY3Rpb24gKHQpIHtcInVzZSBzdHJpY3RcIjsgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygd2luZG93ID8gd2luZG93IDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgZ2xvYmFsID8gZ2xvYmFsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygc2VsZiAmJiBzZWxmOyB2YXIgZSwgaSwgbiA9IChmdW5jdGlvbiAodCwgZSkgeyhmdW5jdGlvbiAodCkge09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiAhMH0pOyB2YXIgbCwgbiwgZSA9IGZ1bmN0aW9uICgpIHtmdW5jdGlvbiBuKHQsIGUpIHtmb3IgKHZhciBpID0gMDsgaSA8IGUubGVuZ3RoOyBpKyspIHt2YXIgbiA9IGVbaV07IG4uZW51bWVyYWJsZSA9IG4uZW51bWVyYWJsZSB8fCAhMSwgbi5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG4gJiYgKG4ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBuLmtleSwgbil9IH0gcmV0dXJuIGZ1bmN0aW9uICh0LCBlLCBpKSB7cmV0dXJuIGUgJiYgbih0LnByb3RvdHlwZSwgZSksIGkgJiYgbih0LCBpKSwgdH19KCksIGkgPSAobCA9IFwiLnN0aWNreVNpZGViYXJcIiwgbiA9IHt0b3BTcGFjaW5nOiAwLCBib3R0b21TcGFjaW5nOiAwLCBjb250YWluZXJTZWxlY3RvcjogITEsIGlubmVyV3JhcHBlclNlbGVjdG9yOiBcIi5pbm5lci13cmFwcGVyLXN0aWNreVwiLCBzdGlja3lDbGFzczogXCJpcy1hZmZpeGVkXCIsIHJlc2l6ZVNlbnNvcjogITAsIG1pbldpZHRoOiAhMX0sIGZ1bmN0aW9uICgpIHtmdW5jdGlvbiBjKHQpIHt2YXIgZSA9IHRoaXMsIGkgPSAxIDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1sxXSA/IGFyZ3VtZW50c1sxXSA6IHt9OyBpZiAoZnVuY3Rpb24gKHQsIGUpIHtpZiAoISh0IGluc3RhbmNlb2YgZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsIGMpLCB0aGlzLm9wdGlvbnMgPSBjLmV4dGVuZChuLCBpKSwgdGhpcy5zaWRlYmFyID0gXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodCkgOiB0LCB2b2lkIDAgPT09IHRoaXMuc2lkZWJhcikgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgaXMgbm8gc3BlY2lmaWMgc2lkZWJhciBlbGVtZW50LlwiKTsgdGhpcy5zaWRlYmFySW5uZXIgPSAhMSwgdGhpcy5jb250YWluZXIgPSB0aGlzLnNpZGViYXIucGFyZW50RWxlbWVudCwgdGhpcy5hZmZpeGVkVHlwZSA9IFwiU1RBVElDXCIsIHRoaXMuZGlyZWN0aW9uID0gXCJkb3duXCIsIHRoaXMuc3VwcG9ydCA9IHt0cmFuc2Zvcm06ICExLCB0cmFuc2Zvcm0zZDogITF9LCB0aGlzLl9pbml0aWFsaXplZCA9ICExLCB0aGlzLl9yZVN0eWxlID0gITEsIHRoaXMuX2JyZWFrcG9pbnQgPSAhMSwgdGhpcy5kaW1lbnNpb25zID0ge3RyYW5zbGF0ZVk6IDAsIG1heFRyYW5zbGF0ZVk6IDAsIHRvcFNwYWNpbmc6IDAsIGxhc3RUb3BTcGFjaW5nOiAwLCBib3R0b21TcGFjaW5nOiAwLCBsYXN0Qm90dG9tU3BhY2luZzogMCwgc2lkZWJhckhlaWdodDogMCwgc2lkZWJhcldpZHRoOiAwLCBjb250YWluZXJUb3A6IDAsIGNvbnRhaW5lckhlaWdodDogMCwgdmlld3BvcnRIZWlnaHQ6IDAsIHZpZXdwb3J0VG9wOiAwLCBsYXN0Vmlld3BvcnRUb3A6IDB9LCBbXCJoYW5kbGVFdmVudFwiXS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7ZVt0XSA9IGVbdF0uYmluZChlKX0pLCB0aGlzLmluaXRpYWxpemUoKX0gcmV0dXJuIGUoYywgW3trZXk6IFwiaW5pdGlhbGl6ZVwiLCB2YWx1ZTogZnVuY3Rpb24gKCkge3ZhciBpID0gdGhpczsgaWYgKHRoaXMuX3NldFN1cHBvcnRGZWF0dXJlcygpLCB0aGlzLm9wdGlvbnMuaW5uZXJXcmFwcGVyU2VsZWN0b3IgJiYgKHRoaXMuc2lkZWJhcklubmVyID0gdGhpcy5zaWRlYmFyLnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zLmlubmVyV3JhcHBlclNlbGVjdG9yKSwgbnVsbCA9PT0gdGhpcy5zaWRlYmFySW5uZXIgJiYgKHRoaXMuc2lkZWJhcklubmVyID0gITEpKSwgIXRoaXMuc2lkZWJhcklubmVyKSB7dmFyIHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpOyBmb3IgKHQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJpbm5lci13cmFwcGVyLXN0aWNreVwiKSwgdGhpcy5zaWRlYmFyLmFwcGVuZENoaWxkKHQpOyB0aGlzLnNpZGViYXIuZmlyc3RDaGlsZCAhPSB0Oyl0LmFwcGVuZENoaWxkKHRoaXMuc2lkZWJhci5maXJzdENoaWxkKTsgdGhpcy5zaWRlYmFySW5uZXIgPSB0aGlzLnNpZGViYXIucXVlcnlTZWxlY3RvcihcIi5pbm5lci13cmFwcGVyLXN0aWNreVwiKX0gaWYgKHRoaXMub3B0aW9ucy5jb250YWluZXJTZWxlY3Rvcikge3ZhciBlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0aGlzLm9wdGlvbnMuY29udGFpbmVyU2VsZWN0b3IpOyBpZiAoKGUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlKSkuZm9yRWFjaChmdW5jdGlvbiAodCwgZSkge3QuY29udGFpbnMoaS5zaWRlYmFyKSAmJiAoaS5jb250YWluZXIgPSB0KX0pLCAhZS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihcIlRoZSBjb250YWluZXIgZG9lcyBub3QgY29udGFpbnMgb24gdGhlIHNpZGViYXIuXCIpfSBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHRoaXMub3B0aW9ucy50b3BTcGFjaW5nICYmICh0aGlzLm9wdGlvbnMudG9wU3BhY2luZyA9IHBhcnNlSW50KHRoaXMub3B0aW9ucy50b3BTcGFjaW5nKSB8fCAwKSwgXCJmdW5jdGlvblwiICE9IHR5cGVvZiB0aGlzLm9wdGlvbnMuYm90dG9tU3BhY2luZyAmJiAodGhpcy5vcHRpb25zLmJvdHRvbVNwYWNpbmcgPSBwYXJzZUludCh0aGlzLm9wdGlvbnMuYm90dG9tU3BhY2luZykgfHwgMCksIHRoaXMuX3dpZHRoQnJlYWtwb2ludCgpLCB0aGlzLmNhbGNEaW1lbnNpb25zKCksIHRoaXMuc3RpY2t5UG9zaXRpb24oKSwgdGhpcy5iaW5kRXZlbnRzKCksIHRoaXMuX2luaXRpYWxpemVkID0gITB9fSwge2tleTogXCJiaW5kRXZlbnRzXCIsIHZhbHVlOiBmdW5jdGlvbiAoKSB7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcywge3Bhc3NpdmU6ICEwLCBjYXB0dXJlOiAhMX0pLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLCB7cGFzc2l2ZTogITAsIGNhcHR1cmU6ICExfSksIHRoaXMuc2lkZWJhci5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlXCIgKyBsLCB0aGlzKSwgdGhpcy5vcHRpb25zLnJlc2l6ZVNlbnNvciAmJiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBSZXNpemVTZW5zb3IgJiYgKG5ldyBSZXNpemVTZW5zb3IodGhpcy5zaWRlYmFySW5uZXIsIHRoaXMuaGFuZGxlRXZlbnQpLCBuZXcgUmVzaXplU2Vuc29yKHRoaXMuY29udGFpbmVyLCB0aGlzLmhhbmRsZUV2ZW50KSl9fSwge2tleTogXCJoYW5kbGVFdmVudFwiLCB2YWx1ZTogZnVuY3Rpb24gKHQpIHt0aGlzLnVwZGF0ZVN0aWNreSh0KX19LCB7a2V5OiBcImNhbGNEaW1lbnNpb25zXCIsIHZhbHVlOiBmdW5jdGlvbiAoKSB7aWYgKCF0aGlzLl9icmVha3BvaW50KSB7dmFyIHQgPSB0aGlzLmRpbWVuc2lvbnM7IHQuY29udGFpbmVyVG9wID0gYy5vZmZzZXRSZWxhdGl2ZSh0aGlzLmNvbnRhaW5lcikudG9wLCB0LmNvbnRhaW5lckhlaWdodCA9IHRoaXMuY29udGFpbmVyLmNsaWVudEhlaWdodCwgdC5jb250YWluZXJCb3R0b20gPSB0LmNvbnRhaW5lclRvcCArIHQuY29udGFpbmVySGVpZ2h0LCB0LnNpZGViYXJIZWlnaHQgPSB0aGlzLnNpZGViYXJJbm5lci5vZmZzZXRIZWlnaHQsIHQuc2lkZWJhcldpZHRoID0gdGhpcy5zaWRlYmFySW5uZXIub2Zmc2V0V2lkdGgsIHQudmlld3BvcnRIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQsIHQubWF4VHJhbnNsYXRlWSA9IHQuY29udGFpbmVySGVpZ2h0IC0gdC5zaWRlYmFySGVpZ2h0LCB0aGlzLl9jYWxjRGltZW5zaW9uc1dpdGhTY3JvbGwoKX0gfX0sIHtrZXk6IFwiX2NhbGNEaW1lbnNpb25zV2l0aFNjcm9sbFwiLCB2YWx1ZTogZnVuY3Rpb24gKCkge3ZhciB0ID0gdGhpcy5kaW1lbnNpb25zOyB0LnNpZGViYXJMZWZ0ID0gYy5vZmZzZXRSZWxhdGl2ZSh0aGlzLnNpZGViYXIpLmxlZnQsIHQudmlld3BvcnRUb3AgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wLCB0LnZpZXdwb3J0Qm90dG9tID0gdC52aWV3cG9ydFRvcCArIHQudmlld3BvcnRIZWlnaHQsIHQudmlld3BvcnRMZWZ0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0LCB0LnRvcFNwYWNpbmcgPSB0aGlzLm9wdGlvbnMudG9wU3BhY2luZywgdC5ib3R0b21TcGFjaW5nID0gdGhpcy5vcHRpb25zLmJvdHRvbVNwYWNpbmcsIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdC50b3BTcGFjaW5nICYmICh0LnRvcFNwYWNpbmcgPSBwYXJzZUludCh0LnRvcFNwYWNpbmcodGhpcy5zaWRlYmFyKSkgfHwgMCksIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdC5ib3R0b21TcGFjaW5nICYmICh0LmJvdHRvbVNwYWNpbmcgPSBwYXJzZUludCh0LmJvdHRvbVNwYWNpbmcodGhpcy5zaWRlYmFyKSkgfHwgMCksIFwiVklFV1BPUlQtVE9QXCIgPT09IHRoaXMuYWZmaXhlZFR5cGUgPyB0LnRvcFNwYWNpbmcgPCB0Lmxhc3RUb3BTcGFjaW5nICYmICh0LnRyYW5zbGF0ZVkgKz0gdC5sYXN0VG9wU3BhY2luZyAtIHQudG9wU3BhY2luZywgdGhpcy5fcmVTdHlsZSA9ICEwKSA6IFwiVklFV1BPUlQtQk9UVE9NXCIgPT09IHRoaXMuYWZmaXhlZFR5cGUgJiYgdC5ib3R0b21TcGFjaW5nIDwgdC5sYXN0Qm90dG9tU3BhY2luZyAmJiAodC50cmFuc2xhdGVZICs9IHQubGFzdEJvdHRvbVNwYWNpbmcgLSB0LmJvdHRvbVNwYWNpbmcsIHRoaXMuX3JlU3R5bGUgPSAhMCksIHQubGFzdFRvcFNwYWNpbmcgPSB0LnRvcFNwYWNpbmcsIHQubGFzdEJvdHRvbVNwYWNpbmcgPSB0LmJvdHRvbVNwYWNpbmd9fSwge2tleTogXCJpc1NpZGViYXJGaXRzVmlld3BvcnRcIiwgdmFsdWU6IGZ1bmN0aW9uICgpIHt2YXIgdCA9IHRoaXMuZGltZW5zaW9ucywgZSA9IFwiZG93blwiID09PSB0aGlzLnNjcm9sbERpcmVjdGlvbiA/IHQubGFzdEJvdHRvbVNwYWNpbmcgOiB0Lmxhc3RUb3BTcGFjaW5nOyByZXR1cm4gdGhpcy5kaW1lbnNpb25zLnNpZGViYXJIZWlnaHQgKyBlIDwgdGhpcy5kaW1lbnNpb25zLnZpZXdwb3J0SGVpZ2h0fX0sIHtrZXk6IFwib2JzZXJ2ZVNjcm9sbERpclwiLCB2YWx1ZTogZnVuY3Rpb24gKCkge3ZhciB0ID0gdGhpcy5kaW1lbnNpb25zOyBpZiAodC5sYXN0Vmlld3BvcnRUb3AgIT09IHQudmlld3BvcnRUb3ApIHt2YXIgZSA9IFwiZG93blwiID09PSB0aGlzLmRpcmVjdGlvbiA/IE1hdGgubWluIDogTWF0aC5tYXg7IHQudmlld3BvcnRUb3AgPT09IGUodC52aWV3cG9ydFRvcCwgdC5sYXN0Vmlld3BvcnRUb3ApICYmICh0aGlzLmRpcmVjdGlvbiA9IFwiZG93blwiID09PSB0aGlzLmRpcmVjdGlvbiA/IFwidXBcIiA6IFwiZG93blwiKX0gfX0sIHtrZXk6IFwiZ2V0QWZmaXhUeXBlXCIsIHZhbHVlOiBmdW5jdGlvbiAoKSB7dGhpcy5fY2FsY0RpbWVuc2lvbnNXaXRoU2Nyb2xsKCk7IHZhciB0ID0gdGhpcy5kaW1lbnNpb25zLCBlID0gdC52aWV3cG9ydFRvcCArIHQudG9wU3BhY2luZywgaSA9IHRoaXMuYWZmaXhlZFR5cGU7IHJldHVybiBlIDw9IHQuY29udGFpbmVyVG9wIHx8IHQuY29udGFpbmVySGVpZ2h0IDw9IHQuc2lkZWJhckhlaWdodCA/ICh0LnRyYW5zbGF0ZVkgPSAwLCBpID0gXCJTVEFUSUNcIikgOiBpID0gXCJ1cFwiID09PSB0aGlzLmRpcmVjdGlvbiA/IHRoaXMuX2dldEFmZml4VHlwZVNjcm9sbGluZ1VwKCkgOiB0aGlzLl9nZXRBZmZpeFR5cGVTY3JvbGxpbmdEb3duKCksIHQudHJhbnNsYXRlWSA9IE1hdGgubWF4KDAsIHQudHJhbnNsYXRlWSksIHQudHJhbnNsYXRlWSA9IE1hdGgubWluKHQuY29udGFpbmVySGVpZ2h0LCB0LnRyYW5zbGF0ZVkpLCB0LnRyYW5zbGF0ZVkgPSBNYXRoLnJvdW5kKHQudHJhbnNsYXRlWSksIHQubGFzdFZpZXdwb3J0VG9wID0gdC52aWV3cG9ydFRvcCwgaX19LCB7a2V5OiBcIl9nZXRBZmZpeFR5cGVTY3JvbGxpbmdEb3duXCIsIHZhbHVlOiBmdW5jdGlvbiAoKSB7dmFyIHQgPSB0aGlzLmRpbWVuc2lvbnMsIGUgPSB0LnNpZGViYXJIZWlnaHQgKyB0LmNvbnRhaW5lclRvcCwgaSA9IHQudmlld3BvcnRUb3AgKyB0LnRvcFNwYWNpbmcsIG4gPSB0LnZpZXdwb3J0Qm90dG9tIC0gdC5ib3R0b21TcGFjaW5nLCBvID0gdGhpcy5hZmZpeGVkVHlwZTsgcmV0dXJuIHRoaXMuaXNTaWRlYmFyRml0c1ZpZXdwb3J0KCkgPyB0LnNpZGViYXJIZWlnaHQgKyBpID49IHQuY29udGFpbmVyQm90dG9tID8gKHQudHJhbnNsYXRlWSA9IHQuY29udGFpbmVyQm90dG9tIC0gZSwgbyA9IFwiQ09OVEFJTkVSLUJPVFRPTVwiKSA6IGkgPj0gdC5jb250YWluZXJUb3AgJiYgKHQudHJhbnNsYXRlWSA9IGkgLSB0LmNvbnRhaW5lclRvcCwgbyA9IFwiVklFV1BPUlQtVE9QXCIpIDogdC5jb250YWluZXJCb3R0b20gPD0gbiA/ICh0LnRyYW5zbGF0ZVkgPSB0LmNvbnRhaW5lckJvdHRvbSAtIGUsIG8gPSBcIkNPTlRBSU5FUi1CT1RUT01cIikgOiBlICsgdC50cmFuc2xhdGVZIDw9IG4gPyAodC50cmFuc2xhdGVZID0gbiAtIGUsIG8gPSBcIlZJRVdQT1JULUJPVFRPTVwiKSA6IHQuY29udGFpbmVyVG9wICsgdC50cmFuc2xhdGVZIDw9IGkgJiYgMCAhPT0gdC50cmFuc2xhdGVZICYmIHQubWF4VHJhbnNsYXRlWSAhPT0gdC50cmFuc2xhdGVZICYmIChvID0gXCJWSUVXUE9SVC1VTkJPVFRPTVwiKSwgb319LCB7a2V5OiBcIl9nZXRBZmZpeFR5cGVTY3JvbGxpbmdVcFwiLCB2YWx1ZTogZnVuY3Rpb24gKCkge3ZhciB0ID0gdGhpcy5kaW1lbnNpb25zLCBlID0gdC5zaWRlYmFySGVpZ2h0ICsgdC5jb250YWluZXJUb3AsIGkgPSB0LnZpZXdwb3J0VG9wICsgdC50b3BTcGFjaW5nLCBuID0gdC52aWV3cG9ydEJvdHRvbSAtIHQuYm90dG9tU3BhY2luZywgbyA9IHRoaXMuYWZmaXhlZFR5cGU7IHJldHVybiBpIDw9IHQudHJhbnNsYXRlWSArIHQuY29udGFpbmVyVG9wID8gKHQudHJhbnNsYXRlWSA9IGkgLSB0LmNvbnRhaW5lclRvcCwgbyA9IFwiVklFV1BPUlQtVE9QXCIpIDogdC5jb250YWluZXJCb3R0b20gPD0gbiA/ICh0LnRyYW5zbGF0ZVkgPSB0LmNvbnRhaW5lckJvdHRvbSAtIGUsIG8gPSBcIkNPTlRBSU5FUi1CT1RUT01cIikgOiB0aGlzLmlzU2lkZWJhckZpdHNWaWV3cG9ydCgpIHx8IHQuY29udGFpbmVyVG9wIDw9IGkgJiYgMCAhPT0gdC50cmFuc2xhdGVZICYmIHQubWF4VHJhbnNsYXRlWSAhPT0gdC50cmFuc2xhdGVZICYmIChvID0gXCJWSUVXUE9SVC1VTkJPVFRPTVwiKSwgb319LCB7a2V5OiBcIl9nZXRTdHlsZVwiLCB2YWx1ZTogZnVuY3Rpb24gKHQpIHtpZiAodm9pZCAwICE9PSB0KSB7dmFyIGUgPSB7aW5uZXI6IHt9LCBvdXRlcjoge319LCBpID0gdGhpcy5kaW1lbnNpb25zOyBzd2l0Y2ggKHQpIHtjYXNlIFwiVklFV1BPUlQtVE9QXCI6IGUuaW5uZXIgPSB7cG9zaXRpb246IFwiZml4ZWRcIiwgdG9wOiBpLnRvcFNwYWNpbmcsIGxlZnQ6IGkuc2lkZWJhckxlZnQgLSBpLnZpZXdwb3J0TGVmdCwgd2lkdGg6IGkuc2lkZWJhcldpZHRofTsgYnJlYWs7IGNhc2UgXCJWSUVXUE9SVC1CT1RUT01cIjogZS5pbm5lciA9IHtwb3NpdGlvbjogXCJmaXhlZFwiLCB0b3A6IFwiYXV0b1wiLCBsZWZ0OiBpLnNpZGViYXJMZWZ0LCBib3R0b206IGkuYm90dG9tU3BhY2luZywgd2lkdGg6IGkuc2lkZWJhcldpZHRofTsgYnJlYWs7IGNhc2UgXCJDT05UQUlORVItQk9UVE9NXCI6IGNhc2UgXCJWSUVXUE9SVC1VTkJPVFRPTVwiOiB2YXIgbiA9IHRoaXMuX2dldFRyYW5zbGF0ZSgwLCBpLnRyYW5zbGF0ZVkgKyBcInB4XCIpOyBlLmlubmVyID0gbiA/IHt0cmFuc2Zvcm06IG59IDoge3Bvc2l0aW9uOiBcImFic29sdXRlXCIsIHRvcDogaS50cmFuc2xhdGVZLCB3aWR0aDogaS5zaWRlYmFyV2lkdGh9fXN3aXRjaCAodCkge2Nhc2UgXCJWSUVXUE9SVC1UT1BcIjogY2FzZSBcIlZJRVdQT1JULUJPVFRPTVwiOiBjYXNlIFwiVklFV1BPUlQtVU5CT1RUT01cIjogY2FzZSBcIkNPTlRBSU5FUi1CT1RUT01cIjogZS5vdXRlciA9IHtoZWlnaHQ6IGkuc2lkZWJhckhlaWdodCwgcG9zaXRpb246IFwicmVsYXRpdmVcIn19cmV0dXJuIGUub3V0ZXIgPSBjLmV4dGVuZCh7aGVpZ2h0OiBcIlwiLCBwb3NpdGlvbjogXCJcIn0sIGUub3V0ZXIpLCBlLmlubmVyID0gYy5leHRlbmQoe3Bvc2l0aW9uOiBcInJlbGF0aXZlXCIsIHRvcDogXCJcIiwgbGVmdDogXCJcIiwgYm90dG9tOiBcIlwiLCB3aWR0aDogXCJcIiwgdHJhbnNmb3JtOiBcIlwifSwgZS5pbm5lciksIGV9IH19LCB7a2V5OiBcInN0aWNreVBvc2l0aW9uXCIsIHZhbHVlOiBmdW5jdGlvbiAodCkge2lmICghdGhpcy5fYnJlYWtwb2ludCkge3QgPSB0aGlzLl9yZVN0eWxlIHx8IHQgfHwgITEsIHRoaXMub3B0aW9ucy50b3BTcGFjaW5nLCB0aGlzLm9wdGlvbnMuYm90dG9tU3BhY2luZzsgdmFyIGUgPSB0aGlzLmdldEFmZml4VHlwZSgpLCBpID0gdGhpcy5fZ2V0U3R5bGUoZSk7IGlmICgodGhpcy5hZmZpeGVkVHlwZSAhPSBlIHx8IHQpICYmIGUpIHt2YXIgbiA9IFwiYWZmaXguXCIgKyBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZShcInZpZXdwb3J0LVwiLCBcIlwiKSArIGw7IGZvciAodmFyIG8gaW4gYy5ldmVudFRyaWdnZXIodGhpcy5zaWRlYmFyLCBuKSwgXCJTVEFUSUNcIiA9PT0gZSA/IGMucmVtb3ZlQ2xhc3ModGhpcy5zaWRlYmFyLCB0aGlzLm9wdGlvbnMuc3RpY2t5Q2xhc3MpIDogYy5hZGRDbGFzcyh0aGlzLnNpZGViYXIsIHRoaXMub3B0aW9ucy5zdGlja3lDbGFzcyksIGkub3V0ZXIpIHt2YXIgcyA9IFwibnVtYmVyXCIgPT0gdHlwZW9mIGkub3V0ZXJbb10gPyBcInB4XCIgOiBcIlwiOyB0aGlzLnNpZGViYXIuc3R5bGVbb10gPSBpLm91dGVyW29dICsgc30gZm9yICh2YXIgciBpbiBpLmlubmVyKSB7dmFyIGEgPSBcIm51bWJlclwiID09IHR5cGVvZiBpLmlubmVyW3JdID8gXCJweFwiIDogXCJcIjsgdGhpcy5zaWRlYmFySW5uZXIuc3R5bGVbcl0gPSBpLmlubmVyW3JdICsgYX0gdmFyIHAgPSBcImFmZml4ZWQuXCIgKyBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZShcInZpZXdwb3J0LVwiLCBcIlwiKSArIGw7IGMuZXZlbnRUcmlnZ2VyKHRoaXMuc2lkZWJhciwgcCl9IGVsc2UgdGhpcy5faW5pdGlhbGl6ZWQgJiYgKHRoaXMuc2lkZWJhcklubmVyLnN0eWxlLmxlZnQgPSBpLmlubmVyLmxlZnQpOyB0aGlzLmFmZml4ZWRUeXBlID0gZX0gfX0sIHtrZXk6IFwiX3dpZHRoQnJlYWtwb2ludFwiLCB2YWx1ZTogZnVuY3Rpb24gKCkge3dpbmRvdy5pbm5lcldpZHRoIDw9IHRoaXMub3B0aW9ucy5taW5XaWR0aCA/ICh0aGlzLl9icmVha3BvaW50ID0gITAsIHRoaXMuYWZmaXhlZFR5cGUgPSBcIlNUQVRJQ1wiLCB0aGlzLnNpZGViYXIucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIiksIGMucmVtb3ZlQ2xhc3ModGhpcy5zaWRlYmFyLCB0aGlzLm9wdGlvbnMuc3RpY2t5Q2xhc3MpLCB0aGlzLnNpZGViYXJJbm5lci5yZW1vdmVBdHRyaWJ1dGUoXCJzdHlsZVwiKSkgOiB0aGlzLl9icmVha3BvaW50ID0gITF9fSwge2tleTogXCJ1cGRhdGVTdGlja3lcIiwgdmFsdWU6IGZ1bmN0aW9uICgpIHt2YXIgdCwgZSA9IHRoaXMsIGkgPSAwIDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1swXSA/IGFyZ3VtZW50c1swXSA6IHt9OyB0aGlzLl9ydW5uaW5nIHx8ICh0aGlzLl9ydW5uaW5nID0gITAsIHQgPSBpLnR5cGUsIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7c3dpdGNoICh0KSB7Y2FzZSBcInNjcm9sbFwiOiBlLl9jYWxjRGltZW5zaW9uc1dpdGhTY3JvbGwoKSwgZS5vYnNlcnZlU2Nyb2xsRGlyKCksIGUuc3RpY2t5UG9zaXRpb24oKTsgYnJlYWs7IGNhc2UgXCJyZXNpemVcIjogZGVmYXVsdDogZS5fd2lkdGhCcmVha3BvaW50KCksIGUuY2FsY0RpbWVuc2lvbnMoKSwgZS5zdGlja3lQb3NpdGlvbighMCl9ZS5fcnVubmluZyA9ICExfSkpfX0sIHtrZXk6IFwiX3NldFN1cHBvcnRGZWF0dXJlc1wiLCB2YWx1ZTogZnVuY3Rpb24gKCkge3ZhciB0ID0gdGhpcy5zdXBwb3J0OyB0LnRyYW5zZm9ybSA9IGMuc3VwcG9ydFRyYW5zZm9ybSgpLCB0LnRyYW5zZm9ybTNkID0gYy5zdXBwb3J0VHJhbnNmb3JtKCEwKX19LCB7a2V5OiBcIl9nZXRUcmFuc2xhdGVcIiwgdmFsdWU6IGZ1bmN0aW9uICgpIHt2YXIgdCA9IDAgPCBhcmd1bWVudHMubGVuZ3RoICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzBdID8gYXJndW1lbnRzWzBdIDogMCwgZSA9IDEgPCBhcmd1bWVudHMubGVuZ3RoICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzFdID8gYXJndW1lbnRzWzFdIDogMCwgaSA9IDIgPCBhcmd1bWVudHMubGVuZ3RoICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzJdID8gYXJndW1lbnRzWzJdIDogMDsgcmV0dXJuIHRoaXMuc3VwcG9ydC50cmFuc2Zvcm0zZCA/IFwidHJhbnNsYXRlM2QoXCIgKyB0ICsgXCIsIFwiICsgZSArIFwiLCBcIiArIGkgKyBcIilcIiA6ICEhdGhpcy5zdXBwb3J0LnRyYW5zbGF0ZSAmJiBcInRyYW5zbGF0ZShcIiArIHQgKyBcIiwgXCIgKyBlICsgXCIpXCJ9fSwge2tleTogXCJkZXN0cm95XCIsIHZhbHVlOiBmdW5jdGlvbiAoKSB7d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcywge2NhcHR1cmU6ICExfSksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMsIHtjYXB0dXJlOiAhMX0pLCB0aGlzLnNpZGViYXIuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLm9wdGlvbnMuc3RpY2t5Q2xhc3MpLCB0aGlzLnNpZGViYXIuc3R5bGUubWluSGVpZ2h0ID0gXCJcIiwgdGhpcy5zaWRlYmFyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVcIiArIGwsIHRoaXMpOyB2YXIgdCA9IHtpbm5lcjoge30sIG91dGVyOiB7fX07IGZvciAodmFyIGUgaW4gdC5pbm5lciA9IHtwb3NpdGlvbjogXCJcIiwgdG9wOiBcIlwiLCBsZWZ0OiBcIlwiLCBib3R0b206IFwiXCIsIHdpZHRoOiBcIlwiLCB0cmFuc2Zvcm06IFwiXCJ9LCB0Lm91dGVyID0ge2hlaWdodDogXCJcIiwgcG9zaXRpb246IFwiXCJ9LCB0Lm91dGVyKSB0aGlzLnNpZGViYXIuc3R5bGVbZV0gPSB0Lm91dGVyW2VdOyBmb3IgKHZhciBpIGluIHQuaW5uZXIpIHRoaXMuc2lkZWJhcklubmVyLnN0eWxlW2ldID0gdC5pbm5lcltpXTsgdGhpcy5vcHRpb25zLnJlc2l6ZVNlbnNvciAmJiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBSZXNpemVTZW5zb3IgJiYgKFJlc2l6ZVNlbnNvci5kZXRhY2godGhpcy5zaWRlYmFySW5uZXIsIHRoaXMuaGFuZGxlRXZlbnQpLCBSZXNpemVTZW5zb3IuZGV0YWNoKHRoaXMuY29udGFpbmVyLCB0aGlzLmhhbmRsZUV2ZW50KSl9fV0sIFt7a2V5OiBcInN1cHBvcnRUcmFuc2Zvcm1cIiwgdmFsdWU6IGZ1bmN0aW9uICh0KSB7dmFyIGkgPSAhMSwgZSA9IHQgPyBcInBlcnNwZWN0aXZlXCIgOiBcInRyYW5zZm9ybVwiLCBuID0gZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGUuc2xpY2UoMSksIG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3VwcG9ydFwiKS5zdHlsZTsgcmV0dXJuIChlICsgXCIgXCIgKyBbXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJPXCIsIFwibXNcIl0uam9pbihuICsgXCIgXCIpICsgbikuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24gKHQsIGUpIHtpZiAodm9pZCAwICE9PSBvW3RdKSByZXR1cm4gaSA9IHQsICExfSksIGl9fSwge2tleTogXCJldmVudFRyaWdnZXJcIiwgdmFsdWU6IGZ1bmN0aW9uICh0LCBlLCBpKSB7dHJ5IHt2YXIgbiA9IG5ldyBDdXN0b21FdmVudChlLCB7ZGV0YWlsOiBpfSl9IGNhdGNoICh0KSB7KG4gPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpKS5pbml0Q3VzdG9tRXZlbnQoZSwgITAsICEwLCBpKX0gdC5kaXNwYXRjaEV2ZW50KG4pfX0sIHtrZXk6IFwiZXh0ZW5kXCIsIHZhbHVlOiBmdW5jdGlvbiAodCwgZSkge3ZhciBpID0ge307IGZvciAodmFyIG4gaW4gdCkgdm9pZCAwICE9PSBlW25dID8gaVtuXSA9IGVbbl0gOiBpW25dID0gdFtuXTsgcmV0dXJuIGl9fSwge2tleTogXCJvZmZzZXRSZWxhdGl2ZVwiLCB2YWx1ZTogZnVuY3Rpb24gKHQpIHt2YXIgZSA9IHtsZWZ0OiAwLCB0b3A6IDB9OyBkbyB7dmFyIGkgPSB0Lm9mZnNldFRvcCwgbiA9IHQub2Zmc2V0TGVmdDsgaXNOYU4oaSkgfHwgKGUudG9wICs9IGkpLCBpc05hTihuKSB8fCAoZS5sZWZ0ICs9IG4pLCB0ID0gXCJCT0RZXCIgPT09IHQudGFnTmFtZSA/IHQucGFyZW50RWxlbWVudCA6IHQub2Zmc2V0UGFyZW50fSB3aGlsZSAodCk7IHJldHVybiBlfX0sIHtrZXk6IFwiYWRkQ2xhc3NcIiwgdmFsdWU6IGZ1bmN0aW9uICh0LCBlKSB7Yy5oYXNDbGFzcyh0LCBlKSB8fCAodC5jbGFzc0xpc3QgPyB0LmNsYXNzTGlzdC5hZGQoZSkgOiB0LmNsYXNzTmFtZSArPSBcIiBcIiArIGUpfX0sIHtrZXk6IFwicmVtb3ZlQ2xhc3NcIiwgdmFsdWU6IGZ1bmN0aW9uICh0LCBlKSB7Yy5oYXNDbGFzcyh0LCBlKSAmJiAodC5jbGFzc0xpc3QgPyB0LmNsYXNzTGlzdC5yZW1vdmUoZSkgOiB0LmNsYXNzTmFtZSA9IHQuY2xhc3NOYW1lLnJlcGxhY2UobmV3IFJlZ0V4cChcIihefFxcXFxiKVwiICsgZS5zcGxpdChcIiBcIikuam9pbihcInxcIikgKyBcIihcXFxcYnwkKVwiLCBcImdpXCIpLCBcIiBcIikpfX0sIHtrZXk6IFwiaGFzQ2xhc3NcIiwgdmFsdWU6IGZ1bmN0aW9uICh0LCBlKSB7cmV0dXJuIHQuY2xhc3NMaXN0ID8gdC5jbGFzc0xpc3QuY29udGFpbnMoZSkgOiBuZXcgUmVnRXhwKFwiKF58IClcIiArIGUgKyBcIiggfCQpXCIsIFwiZ2lcIikudGVzdCh0LmNsYXNzTmFtZSl9fSwge2tleTogXCJkZWZhdWx0c1wiLCBnZXQ6IGZ1bmN0aW9uICgpIHtyZXR1cm4gbn19XSksIGN9KCkpOyB0LmRlZmF1bHQgPSBpLCB3aW5kb3cuU3RpY2t5U2lkZWJhciA9IGl9KShlKX0oZSA9IHtleHBvcnRzOiB7fX0sIGUuZXhwb3J0cyksIGUuZXhwb3J0cyksIG8gPSAoaSA9IG4pICYmIGkuX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaSwgXCJkZWZhdWx0XCIpID8gaS5kZWZhdWx0IDogaTsgdC5kZWZhdWx0ID0gbywgdC5fX21vZHVsZUV4cG9ydHMgPSBuLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogITB9KX0pO1xuXG5pZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmpzLXN0aWNreS1zaWRlYmFyJykpIHtcbiAgICB2YXIgc2lkZWJhciA9IG5ldyBTdGlja3lTaWRlYmFyKCcuanMtc3RpY2t5LXNpZGViYXInLCB7XG4gICAgICAgIHRvcFNwYWNpbmc6IDIwLFxuICAgICAgICBib3R0b21TcGFjaW5nOiAyMCxcbiAgICAgICAgY29udGFpbmVyU2VsZWN0b3I6ICcuanMtc3RpY2t5LW1haW4tY29udGVudCcsXG4gICAgICAgIGlubmVyV3JhcHBlclNlbGVjdG9yOiAnLmpzLXN0aWNreS1zaWRlYmFyX19pbm5lcicsXG4gICAgICAgIG1pbldpZHRoOiAxMDI0XG4gICAgfSk7XG59XG4iXX0=
