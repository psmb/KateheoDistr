!function (e, t) {if ("object" == typeof exports && "object" == typeof module) module.exports = t(); else if ("function" == typeof define && define.amd) define([], t); else {var n = t(); for (var i in n) ("object" == typeof exports ? exports : e)[i] = n[i]} }(this, function () {return function (e) {function t(i) {if (n[i]) return n[i].exports; var o = n[i] = {exports: {}, id: i, loaded: !1}; return e[i].call(o.exports, o, o.exports, t), o.loaded = !0, o.exports} var n = {}; return t.m = e, t.c = n, t.p = "", t(0)}([function (e, t, n) {e.exports = n(1)}, function (e, t, n) {"use strict"; function i(e) {return e && e.__esModule ? e : {"default": e}} function o(e, t) {function n(e, t) {var n = z, i = n.classNameActiveSlide; e.forEach(function (e, t) {e.classList.contains(i) && e.classList.remove(i)}), e[t].classList.add(i)} function i(e) {var t = z, n = t.infinite, i = e.slice(0, n), o = e.slice(e.length - n, e.length); return i.forEach(function (e) {var t = e.cloneNode(!0); B.appendChild(t)}), o.reverse().forEach(function (e) {var t = e.cloneNode(!0); B.insertBefore(t, B.firstChild)}), B.addEventListener(O.transitionEnd, y), f.call(B.children)} function o(t, n, i) {(0, l["default"])(e, t + ".lory." + n, i)} function a(e, t, n) {var i = B && B.style; i && (i[O.transition + "TimingFunction"] = n, i[O.transition + "Duration"] = t + "ms", O.hasTranslate3d ? i[O.transform] = "translate3d(" + e + "px, 0, 0)" : i[O.transform] = "translate(" + e + "px, 0)")} function d(e, t) {var i = z, r = i.slideSpeed, s = i.slidesToScroll, d = i.infinite, l = i.rewind, c = i.rewindSpeed, u = i.ease, v = i.classNameActiveSlide, m = r, p = t ? P + 1 : P - 1, h = Math.round(M - S); o("before", "slide", {index: P, nextSlide: p}), "number" != typeof e && (e = t ? P + s : P - s), e = Math.min(Math.max(e, 0), _.length - 1), d && void 0 === t && (e += d); var E = Math.min(Math.max(_[e].offsetLeft * -1, h * -1), 0); l && Math.abs(N.x) === h && t && (E = 0, e = 0, m = c), a(E, m, u), N.x = E, _[e].offsetLeft <= h && (P = e), !d || e !== _.length - d && 0 !== e || (t && (P = d), t || (P = _.length - 2 * d), N.x = _[P].offsetLeft * -1, A = function () {a(_[P].offsetLeft * -1, 0, void 0)}), v && n(f.call(_), P), o("after", "slide", {currentSlide: P})} function c() {o("before", "init"), O = (0, s["default"])(), z = r({}, u["default"], t); var a = z, d = a.classNameFrame, l = a.classNameSlideContainer, c = a.classNamePrevCtrl, m = a.classNameNextCtrl, p = a.enableMouseEvents, b = a.classNameActiveSlide; j = e.getElementsByClassName(d)[0], B = j.getElementsByClassName(l)[0], k = e.getElementsByClassName(c)[0], T = e.getElementsByClassName(m)[0], N = {x: B.offsetLeft, y: B.offsetTop}, _ = z.infinite ? i(f.call(B.children)) : f.call(B.children), v(), b && n(_, P), k && T && (k.addEventListener("click", h), T.addEventListener("click", E)), j.addEventListener("touchstart", x), p && (j.addEventListener("mousedown", x), j.addEventListener("click", g)), z.window.addEventListener("resize", C), o("after", "init")} function v() {var e = z, t = e.infinite, i = e.ease, o = e.rewindSpeed, r = e.rewindOnResize, s = e.classNameActiveSlide; M = B.getBoundingClientRect().width || B.offsetWidth, S = j.getBoundingClientRect().width || j.offsetWidth, S === M && (M = _.reduce(function (e, t) {return e + t.getBoundingClientRect().width || t.offsetWidth}, 0)), r ? P = 0 : (i = null, o = 0), t ? (a(_[P + t].offsetLeft * -1, 0, null), P += t, N.x = _[P].offsetLeft * -1) : (a(_[P].offsetLeft * -1, o, i), N.x = _[P].offsetLeft * -1), s && n(f.call(_), P)} function m(e) {d(e)} function p() {return P - z.infinite || 0} function h() {d(!1, !1)} function E() {d(!1, !0)} function b() {o("before", "destroy"), j.removeEventListener(O.transitionEnd, y), j.removeEventListener("touchstart", x), j.removeEventListener("touchmove", L), j.removeEventListener("touchend", w), j.removeEventListener("mousemove", L), j.removeEventListener("mousedown", x), j.removeEventListener("mouseup", w), j.removeEventListener("mouseleave", w), j.removeEventListener("click", g), z.window.removeEventListener("resize", C), k && k.removeEventListener("click", h), T && T.removeEventListener("click", E), z.infinite && Array.apply(null, Array(z.infinite)).forEach(function () {B.removeChild(B.firstChild), B.removeChild(B.lastChild)}), o("after", "destroy")} function y() {A && (A(), A = void 0)} function x(e) {var t = z, n = t.enableMouseEvents, i = e.touches ? e.touches[0] : e; n && (j.addEventListener("mousemove", L), j.addEventListener("mouseup", w), j.addEventListener("mouseleave", w)), j.addEventListener("touchmove", L), j.addEventListener("touchend", w); var r = i.pageX, a = i.pageY; D = {x: r, y: a, time: Date.now()}, F = void 0, R = {}, o("on", "touchstart", {event: e})} function L(e) {var t = e.touches ? e.touches[0] : e, n = t.pageX, i = t.pageY; R = {x: n - D.x, y: i - D.y}, "undefined" == typeof F && (F = !!(F || Math.abs(R.x) < Math.abs(R.y))), !F && D && (e.preventDefault(), a(N.x + R.x, 0, null)), o("on", "touchmove", {event: e})} function w(e) {var t = D ? Date.now() - D.time : void 0, n = Number(t) < 300 && Math.abs(R.x) > 25 || Math.abs(R.x) > S / 3, i = !P && R.x > 0 || P === _.length - 1 && R.x < 0, r = R.x < 0; F || (n && !i ? d(!1, r) : a(N.x, z.snapBackSpeed)), D = void 0, j.removeEventListener("touchmove", L), j.removeEventListener("touchend", w), j.removeEventListener("mousemove", L), j.removeEventListener("mouseup", w), j.removeEventListener("mouseleave", w), o("on", "touchend", {event: e})} function g(e) {R.x && e.preventDefault()} function C(e) {v(), o("on", "resize", {event: e})} var N = void 0, M = void 0, S = void 0, _ = void 0, j = void 0, B = void 0, k = void 0, T = void 0, O = void 0, A = void 0, P = 0, z = {}; "undefined" != typeof jQuery && e instanceof jQuery && (e = e[0]); var D = void 0, R = void 0, F = void 0; return c(), {setup: c, reset: v, slideTo: m, returnIndex: p, prev: h, next: E, destroy: b}} Object.defineProperty(t, "__esModule", {value: !0}); var r = Object.assign || function (e) {for (var t = 1; t < arguments.length; t++) {var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])} return e}; t.lory = o; var a = n(2), s = i(a), d = n(3), l = i(d), c = n(5), u = i(c), f = Array.prototype.slice}, function (e, t) {(function (e) {"use strict"; function n() {var t = void 0, n = void 0, i = void 0, o = void 0; return function () {var r = document.createElement("_"), a = r.style, s = void 0; "" === a[s = "webkitTransition"] && (i = "webkitTransitionEnd", n = s), "" === a[s = "transition"] && (i = "transitionend", n = s), "" === a[s = "webkitTransform"] && (t = s), "" === a[s = "msTransform"] && (t = s), "" === a[s = "transform"] && (t = s), document.body.insertBefore(r, null), a[t] = "translate3d(0, 0, 0)", o = !!e.getComputedStyle(r).getPropertyValue(t), document.body.removeChild(r)}(), {transform: t, transition: n, transitionEnd: i, hasTranslate3d: o}} Object.defineProperty(t, "__esModule", {value: !0}), t["default"] = n}).call(t, function () {return this}())}, function (e, t, n) {"use strict"; function i(e) {return e && e.__esModule ? e : {"default": e}} function o(e, t, n) {var i = new a["default"](t, {bubbles: !0, cancelable: !0, detail: n}); e.dispatchEvent(i)} Object.defineProperty(t, "__esModule", {value: !0}), t["default"] = o; var r = n(4), a = i(r)}, function (e, t) {(function (t) {function n() {try {var e = new i("cat", {detail: {foo: "bar"}}); return "cat" === e.type && "bar" === e.detail.foo} catch (t) {} return !1} var i = t.CustomEvent; e.exports = n() ? i : "function" == typeof document.createEvent ? function (e, t) {var n = document.createEvent("CustomEvent"); return t ? n.initCustomEvent(e, t.bubbles, t.cancelable, t.detail) : n.initCustomEvent(e, !1, !1, void 0), n} : function (e, t) {var n = document.createEventObject(); return n.type = e, t ? (n.bubbles = Boolean(t.bubbles), n.cancelable = Boolean(t.cancelable), n.detail = t.detail) : (n.bubbles = !1, n.cancelable = !1, n.detail = void 0), n}}).call(t, function () {return this}())}, function (e, t) {"use strict"; Object.defineProperty(t, "__esModule", {value: !0}), t["default"] = {slidesToScroll: 1, slideSpeed: 300, rewindSpeed: 600, snapBackSpeed: 200, ease: "ease", rewind: !1, infinite: !1, classNameFrame: "js_frame", classNameSlideContainer: "js_slides", classNamePrevCtrl: "js_prev", classNameNextCtrl: "js_next", classNameActiveSlide: "active", enableMouseEvents: !1, window: window, rewindOnResize: !0}}])});

(function () {

    function Carousel(el) {
        // State
        var index;
        var slidesToScroll;
        var instance = lory(el, createSettings());

        function createSettings() {
            index = 0;
            if (el.dataset.carouselPreset === 'announcements') {
                var clientWidth = window.innerWidth;
                slidesToScroll = 2;
                if (clientWidth > 640) {
                    slidesToScroll = 4;
                }
                if (clientWidth > 1200) {
                    slidesToScroll = 5;
                }
            } else {
                slidesToScroll = 1;
            }
            return {
                slidesToScroll: slidesToScroll,
                enableMouseEvents: true
            };
        }

        function updateControls() {
            const next = el.querySelector('.next');
            const prev = el.querySelector('.prev');
            next.classList.remove('disabled');
            prev.classList.remove('disabled');

            var totalItems = el.querySelectorAll('li').length;
            if (totalItems - slidesToScroll <= slidesToScroll * index) {
                next.classList.add('disabled');
            }
            if (index === 0) {
                prev.classList.add('disabled');
            }
        }

        updateControls();

        el.addEventListener('on.lory.resize', function () {
            instance.setup(createSettings());
            updateControls();
        });

        el.addEventListener('before.lory.slide', function (event) {
            if (event.detail.index < event.detail.nextSlide) {
                index++;
            } else {
                index--;
            }
        });

        el.addEventListener('after.lory.slide', function () {
            updateControls();
        });
    }

    // Shuffle Carousel
    [].slice.call(document.querySelectorAll('[data-carousel]')).forEach(function (el) {
        var ul = el.querySelector('ul');
        for (var i = ul.children.length; i >= 0; i--) {
            ul.appendChild(ul.children[Math.random() * i | 0]);
        }
        Carousel(el);
    });
})();

/**
 * sticky-sidebar - A JavaScript plugin for making smart and high performance.
 * @version v3.3.1
 * @link https://github.com/abouolia/sticky-sidebar
 * @author Ahmed Bouhuolia
 * @license The MIT License (MIT)
**/
!function (t, e) {"object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e(t.StickySidebar = {})}(this, function (t) {"use strict"; "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self && self; var e, i, n = (function (t, e) {(function (t) {Object.defineProperty(t, "__esModule", {value: !0}); var l, n, e = function () {function n(t, e) {for (var i = 0; i < e.length; i++) {var n = e[i]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)} } return function (t, e, i) {return e && n(t.prototype, e), i && n(t, i), t}}(), i = (l = ".stickySidebar", n = {topSpacing: 0, bottomSpacing: 0, containerSelector: !1, innerWrapperSelector: ".inner-wrapper-sticky", stickyClass: "is-affixed", resizeSensor: !0, minWidth: !1}, function () {function c(t) {var e = this, i = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}; if (function (t, e) {if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")}(this, c), this.options = c.extend(n, i), this.sidebar = "string" == typeof t ? document.querySelector(t) : t, void 0 === this.sidebar) throw new Error("There is no specific sidebar element."); this.sidebarInner = !1, this.container = this.sidebar.parentElement, this.affixedType = "STATIC", this.direction = "down", this.support = {transform: !1, transform3d: !1}, this._initialized = !1, this._reStyle = !1, this._breakpoint = !1, this.dimensions = {translateY: 0, maxTranslateY: 0, topSpacing: 0, lastTopSpacing: 0, bottomSpacing: 0, lastBottomSpacing: 0, sidebarHeight: 0, sidebarWidth: 0, containerTop: 0, containerHeight: 0, viewportHeight: 0, viewportTop: 0, lastViewportTop: 0}, ["handleEvent"].forEach(function (t) {e[t] = e[t].bind(e)}), this.initialize()} return e(c, [{key: "initialize", value: function () {var i = this; if (this._setSupportFeatures(), this.options.innerWrapperSelector && (this.sidebarInner = this.sidebar.querySelector(this.options.innerWrapperSelector), null === this.sidebarInner && (this.sidebarInner = !1)), !this.sidebarInner) {var t = document.createElement("div"); for (t.setAttribute("class", "inner-wrapper-sticky"), this.sidebar.appendChild(t); this.sidebar.firstChild != t;)t.appendChild(this.sidebar.firstChild); this.sidebarInner = this.sidebar.querySelector(".inner-wrapper-sticky")} if (this.options.containerSelector) {var e = document.querySelectorAll(this.options.containerSelector); if ((e = Array.prototype.slice.call(e)).forEach(function (t, e) {t.contains(i.sidebar) && (i.container = t)}), !e.length) throw new Error("The container does not contains on the sidebar.")} "function" != typeof this.options.topSpacing && (this.options.topSpacing = parseInt(this.options.topSpacing) || 0), "function" != typeof this.options.bottomSpacing && (this.options.bottomSpacing = parseInt(this.options.bottomSpacing) || 0), this._widthBreakpoint(), this.calcDimensions(), this.stickyPosition(), this.bindEvents(), this._initialized = !0}}, {key: "bindEvents", value: function () {window.addEventListener("resize", this, {passive: !0, capture: !1}), window.addEventListener("scroll", this, {passive: !0, capture: !1}), this.sidebar.addEventListener("update" + l, this), this.options.resizeSensor && "undefined" != typeof ResizeSensor && (new ResizeSensor(this.sidebarInner, this.handleEvent), new ResizeSensor(this.container, this.handleEvent))}}, {key: "handleEvent", value: function (t) {this.updateSticky(t)}}, {key: "calcDimensions", value: function () {if (!this._breakpoint) {var t = this.dimensions; t.containerTop = c.offsetRelative(this.container).top, t.containerHeight = this.container.clientHeight, t.containerBottom = t.containerTop + t.containerHeight, t.sidebarHeight = this.sidebarInner.offsetHeight, t.sidebarWidth = this.sidebarInner.offsetWidth, t.viewportHeight = window.innerHeight, t.maxTranslateY = t.containerHeight - t.sidebarHeight, this._calcDimensionsWithScroll()} }}, {key: "_calcDimensionsWithScroll", value: function () {var t = this.dimensions; t.sidebarLeft = c.offsetRelative(this.sidebar).left, t.viewportTop = document.documentElement.scrollTop || document.body.scrollTop, t.viewportBottom = t.viewportTop + t.viewportHeight, t.viewportLeft = document.documentElement.scrollLeft || document.body.scrollLeft, t.topSpacing = this.options.topSpacing, t.bottomSpacing = this.options.bottomSpacing, "function" == typeof t.topSpacing && (t.topSpacing = parseInt(t.topSpacing(this.sidebar)) || 0), "function" == typeof t.bottomSpacing && (t.bottomSpacing = parseInt(t.bottomSpacing(this.sidebar)) || 0), "VIEWPORT-TOP" === this.affixedType ? t.topSpacing < t.lastTopSpacing && (t.translateY += t.lastTopSpacing - t.topSpacing, this._reStyle = !0) : "VIEWPORT-BOTTOM" === this.affixedType && t.bottomSpacing < t.lastBottomSpacing && (t.translateY += t.lastBottomSpacing - t.bottomSpacing, this._reStyle = !0), t.lastTopSpacing = t.topSpacing, t.lastBottomSpacing = t.bottomSpacing}}, {key: "isSidebarFitsViewport", value: function () {var t = this.dimensions, e = "down" === this.scrollDirection ? t.lastBottomSpacing : t.lastTopSpacing; return this.dimensions.sidebarHeight + e < this.dimensions.viewportHeight}}, {key: "observeScrollDir", value: function () {var t = this.dimensions; if (t.lastViewportTop !== t.viewportTop) {var e = "down" === this.direction ? Math.min : Math.max; t.viewportTop === e(t.viewportTop, t.lastViewportTop) && (this.direction = "down" === this.direction ? "up" : "down")} }}, {key: "getAffixType", value: function () {this._calcDimensionsWithScroll(); var t = this.dimensions, e = t.viewportTop + t.topSpacing, i = this.affixedType; return e <= t.containerTop || t.containerHeight <= t.sidebarHeight ? (t.translateY = 0, i = "STATIC") : i = "up" === this.direction ? this._getAffixTypeScrollingUp() : this._getAffixTypeScrollingDown(), t.translateY = Math.max(0, t.translateY), t.translateY = Math.min(t.containerHeight, t.translateY), t.translateY = Math.round(t.translateY), t.lastViewportTop = t.viewportTop, i}}, {key: "_getAffixTypeScrollingDown", value: function () {var t = this.dimensions, e = t.sidebarHeight + t.containerTop, i = t.viewportTop + t.topSpacing, n = t.viewportBottom - t.bottomSpacing, o = this.affixedType; return this.isSidebarFitsViewport() ? t.sidebarHeight + i >= t.containerBottom ? (t.translateY = t.containerBottom - e, o = "CONTAINER-BOTTOM") : i >= t.containerTop && (t.translateY = i - t.containerTop, o = "VIEWPORT-TOP") : t.containerBottom <= n ? (t.translateY = t.containerBottom - e, o = "CONTAINER-BOTTOM") : e + t.translateY <= n ? (t.translateY = n - e, o = "VIEWPORT-BOTTOM") : t.containerTop + t.translateY <= i && 0 !== t.translateY && t.maxTranslateY !== t.translateY && (o = "VIEWPORT-UNBOTTOM"), o}}, {key: "_getAffixTypeScrollingUp", value: function () {var t = this.dimensions, e = t.sidebarHeight + t.containerTop, i = t.viewportTop + t.topSpacing, n = t.viewportBottom - t.bottomSpacing, o = this.affixedType; return i <= t.translateY + t.containerTop ? (t.translateY = i - t.containerTop, o = "VIEWPORT-TOP") : t.containerBottom <= n ? (t.translateY = t.containerBottom - e, o = "CONTAINER-BOTTOM") : this.isSidebarFitsViewport() || t.containerTop <= i && 0 !== t.translateY && t.maxTranslateY !== t.translateY && (o = "VIEWPORT-UNBOTTOM"), o}}, {key: "_getStyle", value: function (t) {if (void 0 !== t) {var e = {inner: {}, outer: {}}, i = this.dimensions; switch (t) {case "VIEWPORT-TOP": e.inner = {position: "fixed", top: i.topSpacing, left: i.sidebarLeft - i.viewportLeft, width: i.sidebarWidth}; break; case "VIEWPORT-BOTTOM": e.inner = {position: "fixed", top: "auto", left: i.sidebarLeft, bottom: i.bottomSpacing, width: i.sidebarWidth}; break; case "CONTAINER-BOTTOM": case "VIEWPORT-UNBOTTOM": var n = this._getTranslate(0, i.translateY + "px"); e.inner = n ? {transform: n} : {position: "absolute", top: i.translateY, width: i.sidebarWidth}}switch (t) {case "VIEWPORT-TOP": case "VIEWPORT-BOTTOM": case "VIEWPORT-UNBOTTOM": case "CONTAINER-BOTTOM": e.outer = {height: i.sidebarHeight, position: "relative"}}return e.outer = c.extend({height: "", position: ""}, e.outer), e.inner = c.extend({position: "relative", top: "", left: "", bottom: "", width: "", transform: ""}, e.inner), e} }}, {key: "stickyPosition", value: function (t) {if (!this._breakpoint) {t = this._reStyle || t || !1, this.options.topSpacing, this.options.bottomSpacing; var e = this.getAffixType(), i = this._getStyle(e); if ((this.affixedType != e || t) && e) {var n = "affix." + e.toLowerCase().replace("viewport-", "") + l; for (var o in c.eventTrigger(this.sidebar, n), "STATIC" === e ? c.removeClass(this.sidebar, this.options.stickyClass) : c.addClass(this.sidebar, this.options.stickyClass), i.outer) {var s = "number" == typeof i.outer[o] ? "px" : ""; this.sidebar.style[o] = i.outer[o] + s} for (var r in i.inner) {var a = "number" == typeof i.inner[r] ? "px" : ""; this.sidebarInner.style[r] = i.inner[r] + a} var p = "affixed." + e.toLowerCase().replace("viewport-", "") + l; c.eventTrigger(this.sidebar, p)} else this._initialized && (this.sidebarInner.style.left = i.inner.left); this.affixedType = e} }}, {key: "_widthBreakpoint", value: function () {window.innerWidth <= this.options.minWidth ? (this._breakpoint = !0, this.affixedType = "STATIC", this.sidebar.removeAttribute("style"), c.removeClass(this.sidebar, this.options.stickyClass), this.sidebarInner.removeAttribute("style")) : this._breakpoint = !1}}, {key: "updateSticky", value: function () {var t, e = this, i = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {}; this._running || (this._running = !0, t = i.type, requestAnimationFrame(function () {switch (t) {case "scroll": e._calcDimensionsWithScroll(), e.observeScrollDir(), e.stickyPosition(); break; case "resize": default: e._widthBreakpoint(), e.calcDimensions(), e.stickyPosition(!0)}e._running = !1}))}}, {key: "_setSupportFeatures", value: function () {var t = this.support; t.transform = c.supportTransform(), t.transform3d = c.supportTransform(!0)}}, {key: "_getTranslate", value: function () {var t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0; return this.support.transform3d ? "translate3d(" + t + ", " + e + ", " + i + ")" : !!this.support.translate && "translate(" + t + ", " + e + ")"}}, {key: "destroy", value: function () {window.removeEventListener("resize", this, {capture: !1}), window.removeEventListener("scroll", this, {capture: !1}), this.sidebar.classList.remove(this.options.stickyClass), this.sidebar.style.minHeight = "", this.sidebar.removeEventListener("update" + l, this); var t = {inner: {}, outer: {}}; for (var e in t.inner = {position: "", top: "", left: "", bottom: "", width: "", transform: ""}, t.outer = {height: "", position: ""}, t.outer) this.sidebar.style[e] = t.outer[e]; for (var i in t.inner) this.sidebarInner.style[i] = t.inner[i]; this.options.resizeSensor && "undefined" != typeof ResizeSensor && (ResizeSensor.detach(this.sidebarInner, this.handleEvent), ResizeSensor.detach(this.container, this.handleEvent))}}], [{key: "supportTransform", value: function (t) {var i = !1, e = t ? "perspective" : "transform", n = e.charAt(0).toUpperCase() + e.slice(1), o = document.createElement("support").style; return (e + " " + ["Webkit", "Moz", "O", "ms"].join(n + " ") + n).split(" ").forEach(function (t, e) {if (void 0 !== o[t]) return i = t, !1}), i}}, {key: "eventTrigger", value: function (t, e, i) {try {var n = new CustomEvent(e, {detail: i})} catch (t) {(n = document.createEvent("CustomEvent")).initCustomEvent(e, !0, !0, i)} t.dispatchEvent(n)}}, {key: "extend", value: function (t, e) {var i = {}; for (var n in t) void 0 !== e[n] ? i[n] = e[n] : i[n] = t[n]; return i}}, {key: "offsetRelative", value: function (t) {var e = {left: 0, top: 0}; do {var i = t.offsetTop, n = t.offsetLeft; isNaN(i) || (e.top += i), isNaN(n) || (e.left += n), t = "BODY" === t.tagName ? t.parentElement : t.offsetParent} while (t); return e}}, {key: "addClass", value: function (t, e) {c.hasClass(t, e) || (t.classList ? t.classList.add(e) : t.className += " " + e)}}, {key: "removeClass", value: function (t, e) {c.hasClass(t, e) && (t.classList ? t.classList.remove(e) : t.className = t.className.replace(new RegExp("(^|\\b)" + e.split(" ").join("|") + "(\\b|$)", "gi"), " "))}}, {key: "hasClass", value: function (t, e) {return t.classList ? t.classList.contains(e) : new RegExp("(^| )" + e + "( |$)", "gi").test(t.className)}}, {key: "defaults", get: function () {return n}}]), c}()); t.default = i, window.StickySidebar = i})(e)}(e = {exports: {}}, e.exports), e.exports), o = (i = n) && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i; t.default = o, t.__moduleExports = n, Object.defineProperty(t, "__esModule", {value: !0})});

if (document.querySelector('.js-sticky-sidebar')) {
    var sidebar = new StickySidebar('.js-sticky-sidebar', {
        topSpacing: 20,
        bottomSpacing: 20,
        containerSelector: '.js-sticky-main-content',
        innerWrapperSelector: '.js-sticky-sidebar__inner',
        minWidth: 1024
    });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInZlbmRvci1sb3J5LmpzIiwidmVuZG9yLXN0aWNreS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24gKGUsIHQpIHtpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZXhwb3J0cyAmJiBcIm9iamVjdFwiID09IHR5cGVvZiBtb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gdCgpOyBlbHNlIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kKSBkZWZpbmUoW10sIHQpOyBlbHNlIHt2YXIgbiA9IHQoKTsgZm9yICh2YXIgaSBpbiBuKSAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZXhwb3J0cyA/IGV4cG9ydHMgOiBlKVtpXSA9IG5baV19IH0odGhpcywgZnVuY3Rpb24gKCkge3JldHVybiBmdW5jdGlvbiAoZSkge2Z1bmN0aW9uIHQoaSkge2lmIChuW2ldKSByZXR1cm4gbltpXS5leHBvcnRzOyB2YXIgbyA9IG5baV0gPSB7ZXhwb3J0czoge30sIGlkOiBpLCBsb2FkZWQ6ICExfTsgcmV0dXJuIGVbaV0uY2FsbChvLmV4cG9ydHMsIG8sIG8uZXhwb3J0cywgdCksIG8ubG9hZGVkID0gITAsIG8uZXhwb3J0c30gdmFyIG4gPSB7fTsgcmV0dXJuIHQubSA9IGUsIHQuYyA9IG4sIHQucCA9IFwiXCIsIHQoMCl9KFtmdW5jdGlvbiAoZSwgdCwgbikge2UuZXhwb3J0cyA9IG4oMSl9LCBmdW5jdGlvbiAoZSwgdCwgbikge1widXNlIHN0cmljdFwiOyBmdW5jdGlvbiBpKGUpIHtyZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDoge1wiZGVmYXVsdFwiOiBlfX0gZnVuY3Rpb24gbyhlLCB0KSB7ZnVuY3Rpb24gbihlLCB0KSB7dmFyIG4gPSB6LCBpID0gbi5jbGFzc05hbWVBY3RpdmVTbGlkZTsgZS5mb3JFYWNoKGZ1bmN0aW9uIChlLCB0KSB7ZS5jbGFzc0xpc3QuY29udGFpbnMoaSkgJiYgZS5jbGFzc0xpc3QucmVtb3ZlKGkpfSksIGVbdF0uY2xhc3NMaXN0LmFkZChpKX0gZnVuY3Rpb24gaShlKSB7dmFyIHQgPSB6LCBuID0gdC5pbmZpbml0ZSwgaSA9IGUuc2xpY2UoMCwgbiksIG8gPSBlLnNsaWNlKGUubGVuZ3RoIC0gbiwgZS5sZW5ndGgpOyByZXR1cm4gaS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7dmFyIHQgPSBlLmNsb25lTm9kZSghMCk7IEIuYXBwZW5kQ2hpbGQodCl9KSwgby5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbiAoZSkge3ZhciB0ID0gZS5jbG9uZU5vZGUoITApOyBCLmluc2VydEJlZm9yZSh0LCBCLmZpcnN0Q2hpbGQpfSksIEIuYWRkRXZlbnRMaXN0ZW5lcihPLnRyYW5zaXRpb25FbmQsIHkpLCBmLmNhbGwoQi5jaGlsZHJlbil9IGZ1bmN0aW9uIG8odCwgbiwgaSkgeygwLCBsW1wiZGVmYXVsdFwiXSkoZSwgdCArIFwiLmxvcnkuXCIgKyBuLCBpKX0gZnVuY3Rpb24gYShlLCB0LCBuKSB7dmFyIGkgPSBCICYmIEIuc3R5bGU7IGkgJiYgKGlbTy50cmFuc2l0aW9uICsgXCJUaW1pbmdGdW5jdGlvblwiXSA9IG4sIGlbTy50cmFuc2l0aW9uICsgXCJEdXJhdGlvblwiXSA9IHQgKyBcIm1zXCIsIE8uaGFzVHJhbnNsYXRlM2QgPyBpW08udHJhbnNmb3JtXSA9IFwidHJhbnNsYXRlM2QoXCIgKyBlICsgXCJweCwgMCwgMClcIiA6IGlbTy50cmFuc2Zvcm1dID0gXCJ0cmFuc2xhdGUoXCIgKyBlICsgXCJweCwgMClcIil9IGZ1bmN0aW9uIGQoZSwgdCkge3ZhciBpID0geiwgciA9IGkuc2xpZGVTcGVlZCwgcyA9IGkuc2xpZGVzVG9TY3JvbGwsIGQgPSBpLmluZmluaXRlLCBsID0gaS5yZXdpbmQsIGMgPSBpLnJld2luZFNwZWVkLCB1ID0gaS5lYXNlLCB2ID0gaS5jbGFzc05hbWVBY3RpdmVTbGlkZSwgbSA9IHIsIHAgPSB0ID8gUCArIDEgOiBQIC0gMSwgaCA9IE1hdGgucm91bmQoTSAtIFMpOyBvKFwiYmVmb3JlXCIsIFwic2xpZGVcIiwge2luZGV4OiBQLCBuZXh0U2xpZGU6IHB9KSwgXCJudW1iZXJcIiAhPSB0eXBlb2YgZSAmJiAoZSA9IHQgPyBQICsgcyA6IFAgLSBzKSwgZSA9IE1hdGgubWluKE1hdGgubWF4KGUsIDApLCBfLmxlbmd0aCAtIDEpLCBkICYmIHZvaWQgMCA9PT0gdCAmJiAoZSArPSBkKTsgdmFyIEUgPSBNYXRoLm1pbihNYXRoLm1heChfW2VdLm9mZnNldExlZnQgKiAtMSwgaCAqIC0xKSwgMCk7IGwgJiYgTWF0aC5hYnMoTi54KSA9PT0gaCAmJiB0ICYmIChFID0gMCwgZSA9IDAsIG0gPSBjKSwgYShFLCBtLCB1KSwgTi54ID0gRSwgX1tlXS5vZmZzZXRMZWZ0IDw9IGggJiYgKFAgPSBlKSwgIWQgfHwgZSAhPT0gXy5sZW5ndGggLSBkICYmIDAgIT09IGUgfHwgKHQgJiYgKFAgPSBkKSwgdCB8fCAoUCA9IF8ubGVuZ3RoIC0gMiAqIGQpLCBOLnggPSBfW1BdLm9mZnNldExlZnQgKiAtMSwgQSA9IGZ1bmN0aW9uICgpIHthKF9bUF0ub2Zmc2V0TGVmdCAqIC0xLCAwLCB2b2lkIDApfSksIHYgJiYgbihmLmNhbGwoXyksIFApLCBvKFwiYWZ0ZXJcIiwgXCJzbGlkZVwiLCB7Y3VycmVudFNsaWRlOiBQfSl9IGZ1bmN0aW9uIGMoKSB7byhcImJlZm9yZVwiLCBcImluaXRcIiksIE8gPSAoMCwgc1tcImRlZmF1bHRcIl0pKCksIHogPSByKHt9LCB1W1wiZGVmYXVsdFwiXSwgdCk7IHZhciBhID0geiwgZCA9IGEuY2xhc3NOYW1lRnJhbWUsIGwgPSBhLmNsYXNzTmFtZVNsaWRlQ29udGFpbmVyLCBjID0gYS5jbGFzc05hbWVQcmV2Q3RybCwgbSA9IGEuY2xhc3NOYW1lTmV4dEN0cmwsIHAgPSBhLmVuYWJsZU1vdXNlRXZlbnRzLCBiID0gYS5jbGFzc05hbWVBY3RpdmVTbGlkZTsgaiA9IGUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShkKVswXSwgQiA9IGouZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShsKVswXSwgayA9IGUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjKVswXSwgVCA9IGUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShtKVswXSwgTiA9IHt4OiBCLm9mZnNldExlZnQsIHk6IEIub2Zmc2V0VG9wfSwgXyA9IHouaW5maW5pdGUgPyBpKGYuY2FsbChCLmNoaWxkcmVuKSkgOiBmLmNhbGwoQi5jaGlsZHJlbiksIHYoKSwgYiAmJiBuKF8sIFApLCBrICYmIFQgJiYgKGsuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGgpLCBULmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBFKSksIGouYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgeCksIHAgJiYgKGouYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB4KSwgai5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZykpLCB6LndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIEMpLCBvKFwiYWZ0ZXJcIiwgXCJpbml0XCIpfSBmdW5jdGlvbiB2KCkge3ZhciBlID0geiwgdCA9IGUuaW5maW5pdGUsIGkgPSBlLmVhc2UsIG8gPSBlLnJld2luZFNwZWVkLCByID0gZS5yZXdpbmRPblJlc2l6ZSwgcyA9IGUuY2xhc3NOYW1lQWN0aXZlU2xpZGU7IE0gPSBCLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHx8IEIub2Zmc2V0V2lkdGgsIFMgPSBqLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHx8IGoub2Zmc2V0V2lkdGgsIFMgPT09IE0gJiYgKE0gPSBfLnJlZHVjZShmdW5jdGlvbiAoZSwgdCkge3JldHVybiBlICsgdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB8fCB0Lm9mZnNldFdpZHRofSwgMCkpLCByID8gUCA9IDAgOiAoaSA9IG51bGwsIG8gPSAwKSwgdCA/IChhKF9bUCArIHRdLm9mZnNldExlZnQgKiAtMSwgMCwgbnVsbCksIFAgKz0gdCwgTi54ID0gX1tQXS5vZmZzZXRMZWZ0ICogLTEpIDogKGEoX1tQXS5vZmZzZXRMZWZ0ICogLTEsIG8sIGkpLCBOLnggPSBfW1BdLm9mZnNldExlZnQgKiAtMSksIHMgJiYgbihmLmNhbGwoXyksIFApfSBmdW5jdGlvbiBtKGUpIHtkKGUpfSBmdW5jdGlvbiBwKCkge3JldHVybiBQIC0gei5pbmZpbml0ZSB8fCAwfSBmdW5jdGlvbiBoKCkge2QoITEsICExKX0gZnVuY3Rpb24gRSgpIHtkKCExLCAhMCl9IGZ1bmN0aW9uIGIoKSB7byhcImJlZm9yZVwiLCBcImRlc3Ryb3lcIiksIGoucmVtb3ZlRXZlbnRMaXN0ZW5lcihPLnRyYW5zaXRpb25FbmQsIHkpLCBqLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHgpLCBqLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgTCksIGoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHcpLCBqLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgTCksIGoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB4KSwgai5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB3KSwgai5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB3KSwgai5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZyksIHoud2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgQyksIGsgJiYgay5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaCksIFQgJiYgVC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgRSksIHouaW5maW5pdGUgJiYgQXJyYXkuYXBwbHkobnVsbCwgQXJyYXkoei5pbmZpbml0ZSkpLmZvckVhY2goZnVuY3Rpb24gKCkge0IucmVtb3ZlQ2hpbGQoQi5maXJzdENoaWxkKSwgQi5yZW1vdmVDaGlsZChCLmxhc3RDaGlsZCl9KSwgbyhcImFmdGVyXCIsIFwiZGVzdHJveVwiKX0gZnVuY3Rpb24geSgpIHtBICYmIChBKCksIEEgPSB2b2lkIDApfSBmdW5jdGlvbiB4KGUpIHt2YXIgdCA9IHosIG4gPSB0LmVuYWJsZU1vdXNlRXZlbnRzLCBpID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTsgbiAmJiAoai5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIEwpLCBqLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHcpLCBqLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHcpKSwgai5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIEwpLCBqLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB3KTsgdmFyIHIgPSBpLnBhZ2VYLCBhID0gaS5wYWdlWTsgRCA9IHt4OiByLCB5OiBhLCB0aW1lOiBEYXRlLm5vdygpfSwgRiA9IHZvaWQgMCwgUiA9IHt9LCBvKFwib25cIiwgXCJ0b3VjaHN0YXJ0XCIsIHtldmVudDogZX0pfSBmdW5jdGlvbiBMKGUpIHt2YXIgdCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGUsIG4gPSB0LnBhZ2VYLCBpID0gdC5wYWdlWTsgUiA9IHt4OiBuIC0gRC54LCB5OiBpIC0gRC55fSwgXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgRiAmJiAoRiA9ICEhKEYgfHwgTWF0aC5hYnMoUi54KSA8IE1hdGguYWJzKFIueSkpKSwgIUYgJiYgRCAmJiAoZS5wcmV2ZW50RGVmYXVsdCgpLCBhKE4ueCArIFIueCwgMCwgbnVsbCkpLCBvKFwib25cIiwgXCJ0b3VjaG1vdmVcIiwge2V2ZW50OiBlfSl9IGZ1bmN0aW9uIHcoZSkge3ZhciB0ID0gRCA/IERhdGUubm93KCkgLSBELnRpbWUgOiB2b2lkIDAsIG4gPSBOdW1iZXIodCkgPCAzMDAgJiYgTWF0aC5hYnMoUi54KSA+IDI1IHx8IE1hdGguYWJzKFIueCkgPiBTIC8gMywgaSA9ICFQICYmIFIueCA+IDAgfHwgUCA9PT0gXy5sZW5ndGggLSAxICYmIFIueCA8IDAsIHIgPSBSLnggPCAwOyBGIHx8IChuICYmICFpID8gZCghMSwgcikgOiBhKE4ueCwgei5zbmFwQmFja1NwZWVkKSksIEQgPSB2b2lkIDAsIGoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBMKSwgai5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdyksIGoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBMKSwgai5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB3KSwgai5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB3KSwgbyhcIm9uXCIsIFwidG91Y2hlbmRcIiwge2V2ZW50OiBlfSl9IGZ1bmN0aW9uIGcoZSkge1IueCAmJiBlLnByZXZlbnREZWZhdWx0KCl9IGZ1bmN0aW9uIEMoZSkge3YoKSwgbyhcIm9uXCIsIFwicmVzaXplXCIsIHtldmVudDogZX0pfSB2YXIgTiA9IHZvaWQgMCwgTSA9IHZvaWQgMCwgUyA9IHZvaWQgMCwgXyA9IHZvaWQgMCwgaiA9IHZvaWQgMCwgQiA9IHZvaWQgMCwgayA9IHZvaWQgMCwgVCA9IHZvaWQgMCwgTyA9IHZvaWQgMCwgQSA9IHZvaWQgMCwgUCA9IDAsIHogPSB7fTsgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgalF1ZXJ5ICYmIGUgaW5zdGFuY2VvZiBqUXVlcnkgJiYgKGUgPSBlWzBdKTsgdmFyIEQgPSB2b2lkIDAsIFIgPSB2b2lkIDAsIEYgPSB2b2lkIDA7IHJldHVybiBjKCksIHtzZXR1cDogYywgcmVzZXQ6IHYsIHNsaWRlVG86IG0sIHJldHVybkluZGV4OiBwLCBwcmV2OiBoLCBuZXh0OiBFLCBkZXN0cm95OiBifX0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6ICEwfSk7IHZhciByID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAoZSkge2ZvciAodmFyIHQgPSAxOyB0IDwgYXJndW1lbnRzLmxlbmd0aDsgdCsrKSB7dmFyIG4gPSBhcmd1bWVudHNbdF07IGZvciAodmFyIGkgaW4gbikgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sIGkpICYmIChlW2ldID0gbltpXSl9IHJldHVybiBlfTsgdC5sb3J5ID0gbzsgdmFyIGEgPSBuKDIpLCBzID0gaShhKSwgZCA9IG4oMyksIGwgPSBpKGQpLCBjID0gbig1KSwgdSA9IGkoYyksIGYgPSBBcnJheS5wcm90b3R5cGUuc2xpY2V9LCBmdW5jdGlvbiAoZSwgdCkgeyhmdW5jdGlvbiAoZSkge1widXNlIHN0cmljdFwiOyBmdW5jdGlvbiBuKCkge3ZhciB0ID0gdm9pZCAwLCBuID0gdm9pZCAwLCBpID0gdm9pZCAwLCBvID0gdm9pZCAwOyByZXR1cm4gZnVuY3Rpb24gKCkge3ZhciByID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIl9cIiksIGEgPSByLnN0eWxlLCBzID0gdm9pZCAwOyBcIlwiID09PSBhW3MgPSBcIndlYmtpdFRyYW5zaXRpb25cIl0gJiYgKGkgPSBcIndlYmtpdFRyYW5zaXRpb25FbmRcIiwgbiA9IHMpLCBcIlwiID09PSBhW3MgPSBcInRyYW5zaXRpb25cIl0gJiYgKGkgPSBcInRyYW5zaXRpb25lbmRcIiwgbiA9IHMpLCBcIlwiID09PSBhW3MgPSBcIndlYmtpdFRyYW5zZm9ybVwiXSAmJiAodCA9IHMpLCBcIlwiID09PSBhW3MgPSBcIm1zVHJhbnNmb3JtXCJdICYmICh0ID0gcyksIFwiXCIgPT09IGFbcyA9IFwidHJhbnNmb3JtXCJdICYmICh0ID0gcyksIGRvY3VtZW50LmJvZHkuaW5zZXJ0QmVmb3JlKHIsIG51bGwpLCBhW3RdID0gXCJ0cmFuc2xhdGUzZCgwLCAwLCAwKVwiLCBvID0gISFlLmdldENvbXB1dGVkU3R5bGUocikuZ2V0UHJvcGVydHlWYWx1ZSh0KSwgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChyKX0oKSwge3RyYW5zZm9ybTogdCwgdHJhbnNpdGlvbjogbiwgdHJhbnNpdGlvbkVuZDogaSwgaGFzVHJhbnNsYXRlM2Q6IG99fSBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogITB9KSwgdFtcImRlZmF1bHRcIl0gPSBufSkuY2FsbCh0LCBmdW5jdGlvbiAoKSB7cmV0dXJuIHRoaXN9KCkpfSwgZnVuY3Rpb24gKGUsIHQsIG4pIHtcInVzZSBzdHJpY3RcIjsgZnVuY3Rpb24gaShlKSB7cmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHtcImRlZmF1bHRcIjogZX19IGZ1bmN0aW9uIG8oZSwgdCwgbikge3ZhciBpID0gbmV3IGFbXCJkZWZhdWx0XCJdKHQsIHtidWJibGVzOiAhMCwgY2FuY2VsYWJsZTogITAsIGRldGFpbDogbn0pOyBlLmRpc3BhdGNoRXZlbnQoaSl9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiAhMH0pLCB0W1wiZGVmYXVsdFwiXSA9IG87IHZhciByID0gbig0KSwgYSA9IGkocil9LCBmdW5jdGlvbiAoZSwgdCkgeyhmdW5jdGlvbiAodCkge2Z1bmN0aW9uIG4oKSB7dHJ5IHt2YXIgZSA9IG5ldyBpKFwiY2F0XCIsIHtkZXRhaWw6IHtmb286IFwiYmFyXCJ9fSk7IHJldHVybiBcImNhdFwiID09PSBlLnR5cGUgJiYgXCJiYXJcIiA9PT0gZS5kZXRhaWwuZm9vfSBjYXRjaCAodCkge30gcmV0dXJuICExfSB2YXIgaSA9IHQuQ3VzdG9tRXZlbnQ7IGUuZXhwb3J0cyA9IG4oKSA/IGkgOiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUV2ZW50ID8gZnVuY3Rpb24gKGUsIHQpIHt2YXIgbiA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7IHJldHVybiB0ID8gbi5pbml0Q3VzdG9tRXZlbnQoZSwgdC5idWJibGVzLCB0LmNhbmNlbGFibGUsIHQuZGV0YWlsKSA6IG4uaW5pdEN1c3RvbUV2ZW50KGUsICExLCAhMSwgdm9pZCAwKSwgbn0gOiBmdW5jdGlvbiAoZSwgdCkge3ZhciBuID0gZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKTsgcmV0dXJuIG4udHlwZSA9IGUsIHQgPyAobi5idWJibGVzID0gQm9vbGVhbih0LmJ1YmJsZXMpLCBuLmNhbmNlbGFibGUgPSBCb29sZWFuKHQuY2FuY2VsYWJsZSksIG4uZGV0YWlsID0gdC5kZXRhaWwpIDogKG4uYnViYmxlcyA9ICExLCBuLmNhbmNlbGFibGUgPSAhMSwgbi5kZXRhaWwgPSB2b2lkIDApLCBufX0pLmNhbGwodCwgZnVuY3Rpb24gKCkge3JldHVybiB0aGlzfSgpKX0sIGZ1bmN0aW9uIChlLCB0KSB7XCJ1c2Ugc3RyaWN0XCI7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiAhMH0pLCB0W1wiZGVmYXVsdFwiXSA9IHtzbGlkZXNUb1Njcm9sbDogMSwgc2xpZGVTcGVlZDogMzAwLCByZXdpbmRTcGVlZDogNjAwLCBzbmFwQmFja1NwZWVkOiAyMDAsIGVhc2U6IFwiZWFzZVwiLCByZXdpbmQ6ICExLCBpbmZpbml0ZTogITEsIGNsYXNzTmFtZUZyYW1lOiBcImpzX2ZyYW1lXCIsIGNsYXNzTmFtZVNsaWRlQ29udGFpbmVyOiBcImpzX3NsaWRlc1wiLCBjbGFzc05hbWVQcmV2Q3RybDogXCJqc19wcmV2XCIsIGNsYXNzTmFtZU5leHRDdHJsOiBcImpzX25leHRcIiwgY2xhc3NOYW1lQWN0aXZlU2xpZGU6IFwiYWN0aXZlXCIsIGVuYWJsZU1vdXNlRXZlbnRzOiAhMSwgd2luZG93OiB3aW5kb3csIHJld2luZE9uUmVzaXplOiAhMH19XSl9KTtcblxuKGZ1bmN0aW9uICgpIHtcblxuICAgIGZ1bmN0aW9uIENhcm91c2VsKGVsKSB7XG4gICAgICAgIC8vIFN0YXRlXG4gICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgdmFyIHNsaWRlc1RvU2Nyb2xsO1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBsb3J5KGVsLCBjcmVhdGVTZXR0aW5ncygpKTtcblxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVTZXR0aW5ncygpIHtcbiAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgICAgIGlmIChlbC5kYXRhc2V0LmNhcm91c2VsUHJlc2V0ID09PSAnYW5ub3VuY2VtZW50cycpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xpZW50V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgICAgICAgICBzbGlkZXNUb1Njcm9sbCA9IDI7XG4gICAgICAgICAgICAgICAgaWYgKGNsaWVudFdpZHRoID4gNjQwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNsaWRlc1RvU2Nyb2xsID0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNsaWVudFdpZHRoID4gMTIwMCkge1xuICAgICAgICAgICAgICAgICAgICBzbGlkZXNUb1Njcm9sbCA9IDU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzbGlkZXNUb1Njcm9sbCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNsaWRlc1RvU2Nyb2xsOiBzbGlkZXNUb1Njcm9sbCxcbiAgICAgICAgICAgICAgICBlbmFibGVNb3VzZUV2ZW50czogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUNvbnRyb2xzKCkge1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJy5uZXh0Jyk7XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gZWwucXVlcnlTZWxlY3RvcignLnByZXYnKTtcbiAgICAgICAgICAgIG5leHQuY2xhc3NMaXN0LnJlbW92ZSgnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIHByZXYuY2xhc3NMaXN0LnJlbW92ZSgnZGlzYWJsZWQnKTtcblxuICAgICAgICAgICAgdmFyIHRvdGFsSXRlbXMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKCdsaScpLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0b3RhbEl0ZW1zIC0gc2xpZGVzVG9TY3JvbGwgPD0gc2xpZGVzVG9TY3JvbGwgKiBpbmRleCkge1xuICAgICAgICAgICAgICAgIG5leHQuY2xhc3NMaXN0LmFkZCgnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHByZXYuY2xhc3NMaXN0LmFkZCgnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZUNvbnRyb2xzKCk7XG5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignb24ubG9yeS5yZXNpemUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXR1cChjcmVhdGVTZXR0aW5ncygpKTtcbiAgICAgICAgICAgIHVwZGF0ZUNvbnRyb2xzKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZS5sb3J5LnNsaWRlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuZGV0YWlsLmluZGV4IDwgZXZlbnQuZGV0YWlsLm5leHRTbGlkZSkge1xuICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZGV4LS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2FmdGVyLmxvcnkuc2xpZGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB1cGRhdGVDb250cm9scygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTaHVmZmxlIENhcm91c2VsXG4gICAgW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1jYXJvdXNlbF0nKSkuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIHVsID0gZWwucXVlcnlTZWxlY3RvcigndWwnKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHVsLmNoaWxkcmVuLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHVsLmFwcGVuZENoaWxkKHVsLmNoaWxkcmVuW01hdGgucmFuZG9tKCkgKiBpIHwgMF0pO1xuICAgICAgICB9XG4gICAgICAgIENhcm91c2VsKGVsKTtcbiAgICB9KTtcbn0pKCk7XG4iLCIvKipcbiAqIHN0aWNreS1zaWRlYmFyIC0gQSBKYXZhU2NyaXB0IHBsdWdpbiBmb3IgbWFraW5nIHNtYXJ0IGFuZCBoaWdoIHBlcmZvcm1hbmNlLlxuICogQHZlcnNpb24gdjMuMy4xXG4gKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vYWJvdW9saWEvc3RpY2t5LXNpZGViYXJcbiAqIEBhdXRob3IgQWhtZWQgQm91aHVvbGlhXG4gKiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbioqL1xuIWZ1bmN0aW9uICh0LCBlKSB7XCJvYmplY3RcIiA9PSB0eXBlb2YgZXhwb3J0cyAmJiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBtb2R1bGUgPyBlKGV4cG9ydHMpIDogXCJmdW5jdGlvblwiID09IHR5cGVvZiBkZWZpbmUgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbXCJleHBvcnRzXCJdLCBlKSA6IGUodC5TdGlja3lTaWRlYmFyID0ge30pfSh0aGlzLCBmdW5jdGlvbiAodCkge1widXNlIHN0cmljdFwiOyBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB3aW5kb3cgPyB3aW5kb3cgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBnbG9iYWwgPyBnbG9iYWwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBzZWxmICYmIHNlbGY7IHZhciBlLCBpLCBuID0gKGZ1bmN0aW9uICh0LCBlKSB7KGZ1bmN0aW9uICh0KSB7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6ICEwfSk7IHZhciBsLCBuLCBlID0gZnVuY3Rpb24gKCkge2Z1bmN0aW9uIG4odCwgZSkge2ZvciAodmFyIGkgPSAwOyBpIDwgZS5sZW5ndGg7IGkrKykge3ZhciBuID0gZVtpXTsgbi5lbnVtZXJhYmxlID0gbi5lbnVtZXJhYmxlIHx8ICExLCBuLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbiAmJiAobi53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIG4ua2V5LCBuKX0gfSByZXR1cm4gZnVuY3Rpb24gKHQsIGUsIGkpIHtyZXR1cm4gZSAmJiBuKHQucHJvdG90eXBlLCBlKSwgaSAmJiBuKHQsIGkpLCB0fX0oKSwgaSA9IChsID0gXCIuc3RpY2t5U2lkZWJhclwiLCBuID0ge3RvcFNwYWNpbmc6IDAsIGJvdHRvbVNwYWNpbmc6IDAsIGNvbnRhaW5lclNlbGVjdG9yOiAhMSwgaW5uZXJXcmFwcGVyU2VsZWN0b3I6IFwiLmlubmVyLXdyYXBwZXItc3RpY2t5XCIsIHN0aWNreUNsYXNzOiBcImlzLWFmZml4ZWRcIiwgcmVzaXplU2Vuc29yOiAhMCwgbWluV2lkdGg6ICExfSwgZnVuY3Rpb24gKCkge2Z1bmN0aW9uIGModCkge3ZhciBlID0gdGhpcywgaSA9IDEgPCBhcmd1bWVudHMubGVuZ3RoICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzFdID8gYXJndW1lbnRzWzFdIDoge307IGlmIChmdW5jdGlvbiAodCwgZSkge2lmICghKHQgaW5zdGFuY2VvZiBlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcywgYyksIHRoaXMub3B0aW9ucyA9IGMuZXh0ZW5kKG4sIGkpLCB0aGlzLnNpZGViYXIgPSBcInN0cmluZ1wiID09IHR5cGVvZiB0ID8gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0KSA6IHQsIHZvaWQgMCA9PT0gdGhpcy5zaWRlYmFyKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBpcyBubyBzcGVjaWZpYyBzaWRlYmFyIGVsZW1lbnQuXCIpOyB0aGlzLnNpZGViYXJJbm5lciA9ICExLCB0aGlzLmNvbnRhaW5lciA9IHRoaXMuc2lkZWJhci5wYXJlbnRFbGVtZW50LCB0aGlzLmFmZml4ZWRUeXBlID0gXCJTVEFUSUNcIiwgdGhpcy5kaXJlY3Rpb24gPSBcImRvd25cIiwgdGhpcy5zdXBwb3J0ID0ge3RyYW5zZm9ybTogITEsIHRyYW5zZm9ybTNkOiAhMX0sIHRoaXMuX2luaXRpYWxpemVkID0gITEsIHRoaXMuX3JlU3R5bGUgPSAhMSwgdGhpcy5fYnJlYWtwb2ludCA9ICExLCB0aGlzLmRpbWVuc2lvbnMgPSB7dHJhbnNsYXRlWTogMCwgbWF4VHJhbnNsYXRlWTogMCwgdG9wU3BhY2luZzogMCwgbGFzdFRvcFNwYWNpbmc6IDAsIGJvdHRvbVNwYWNpbmc6IDAsIGxhc3RCb3R0b21TcGFjaW5nOiAwLCBzaWRlYmFySGVpZ2h0OiAwLCBzaWRlYmFyV2lkdGg6IDAsIGNvbnRhaW5lclRvcDogMCwgY29udGFpbmVySGVpZ2h0OiAwLCB2aWV3cG9ydEhlaWdodDogMCwgdmlld3BvcnRUb3A6IDAsIGxhc3RWaWV3cG9ydFRvcDogMH0sIFtcImhhbmRsZUV2ZW50XCJdLmZvckVhY2goZnVuY3Rpb24gKHQpIHtlW3RdID0gZVt0XS5iaW5kKGUpfSksIHRoaXMuaW5pdGlhbGl6ZSgpfSByZXR1cm4gZShjLCBbe2tleTogXCJpbml0aWFsaXplXCIsIHZhbHVlOiBmdW5jdGlvbiAoKSB7dmFyIGkgPSB0aGlzOyBpZiAodGhpcy5fc2V0U3VwcG9ydEZlYXR1cmVzKCksIHRoaXMub3B0aW9ucy5pbm5lcldyYXBwZXJTZWxlY3RvciAmJiAodGhpcy5zaWRlYmFySW5uZXIgPSB0aGlzLnNpZGViYXIucXVlcnlTZWxlY3Rvcih0aGlzLm9wdGlvbnMuaW5uZXJXcmFwcGVyU2VsZWN0b3IpLCBudWxsID09PSB0aGlzLnNpZGViYXJJbm5lciAmJiAodGhpcy5zaWRlYmFySW5uZXIgPSAhMSkpLCAhdGhpcy5zaWRlYmFySW5uZXIpIHt2YXIgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7IGZvciAodC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImlubmVyLXdyYXBwZXItc3RpY2t5XCIpLCB0aGlzLnNpZGViYXIuYXBwZW5kQ2hpbGQodCk7IHRoaXMuc2lkZWJhci5maXJzdENoaWxkICE9IHQ7KXQuYXBwZW5kQ2hpbGQodGhpcy5zaWRlYmFyLmZpcnN0Q2hpbGQpOyB0aGlzLnNpZGViYXJJbm5lciA9IHRoaXMuc2lkZWJhci5xdWVyeVNlbGVjdG9yKFwiLmlubmVyLXdyYXBwZXItc3RpY2t5XCIpfSBpZiAodGhpcy5vcHRpb25zLmNvbnRhaW5lclNlbGVjdG9yKSB7dmFyIGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMub3B0aW9ucy5jb250YWluZXJTZWxlY3Rvcik7IGlmICgoZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGUpKS5mb3JFYWNoKGZ1bmN0aW9uICh0LCBlKSB7dC5jb250YWlucyhpLnNpZGViYXIpICYmIChpLmNvbnRhaW5lciA9IHQpfSksICFlLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNvbnRhaW5lciBkb2VzIG5vdCBjb250YWlucyBvbiB0aGUgc2lkZWJhci5cIil9IFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdGhpcy5vcHRpb25zLnRvcFNwYWNpbmcgJiYgKHRoaXMub3B0aW9ucy50b3BTcGFjaW5nID0gcGFyc2VJbnQodGhpcy5vcHRpb25zLnRvcFNwYWNpbmcpIHx8IDApLCBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHRoaXMub3B0aW9ucy5ib3R0b21TcGFjaW5nICYmICh0aGlzLm9wdGlvbnMuYm90dG9tU3BhY2luZyA9IHBhcnNlSW50KHRoaXMub3B0aW9ucy5ib3R0b21TcGFjaW5nKSB8fCAwKSwgdGhpcy5fd2lkdGhCcmVha3BvaW50KCksIHRoaXMuY2FsY0RpbWVuc2lvbnMoKSwgdGhpcy5zdGlja3lQb3NpdGlvbigpLCB0aGlzLmJpbmRFdmVudHMoKSwgdGhpcy5faW5pdGlhbGl6ZWQgPSAhMH19LCB7a2V5OiBcImJpbmRFdmVudHNcIiwgdmFsdWU6IGZ1bmN0aW9uICgpIHt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLCB7cGFzc2l2ZTogITAsIGNhcHR1cmU6ICExfSksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMsIHtwYXNzaXZlOiAhMCwgY2FwdHVyZTogITF9KSwgdGhpcy5zaWRlYmFyLmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVcIiArIGwsIHRoaXMpLCB0aGlzLm9wdGlvbnMucmVzaXplU2Vuc29yICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFJlc2l6ZVNlbnNvciAmJiAobmV3IFJlc2l6ZVNlbnNvcih0aGlzLnNpZGViYXJJbm5lciwgdGhpcy5oYW5kbGVFdmVudCksIG5ldyBSZXNpemVTZW5zb3IodGhpcy5jb250YWluZXIsIHRoaXMuaGFuZGxlRXZlbnQpKX19LCB7a2V5OiBcImhhbmRsZUV2ZW50XCIsIHZhbHVlOiBmdW5jdGlvbiAodCkge3RoaXMudXBkYXRlU3RpY2t5KHQpfX0sIHtrZXk6IFwiY2FsY0RpbWVuc2lvbnNcIiwgdmFsdWU6IGZ1bmN0aW9uICgpIHtpZiAoIXRoaXMuX2JyZWFrcG9pbnQpIHt2YXIgdCA9IHRoaXMuZGltZW5zaW9uczsgdC5jb250YWluZXJUb3AgPSBjLm9mZnNldFJlbGF0aXZlKHRoaXMuY29udGFpbmVyKS50b3AsIHQuY29udGFpbmVySGVpZ2h0ID0gdGhpcy5jb250YWluZXIuY2xpZW50SGVpZ2h0LCB0LmNvbnRhaW5lckJvdHRvbSA9IHQuY29udGFpbmVyVG9wICsgdC5jb250YWluZXJIZWlnaHQsIHQuc2lkZWJhckhlaWdodCA9IHRoaXMuc2lkZWJhcklubmVyLm9mZnNldEhlaWdodCwgdC5zaWRlYmFyV2lkdGggPSB0aGlzLnNpZGViYXJJbm5lci5vZmZzZXRXaWR0aCwgdC52aWV3cG9ydEhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCwgdC5tYXhUcmFuc2xhdGVZID0gdC5jb250YWluZXJIZWlnaHQgLSB0LnNpZGViYXJIZWlnaHQsIHRoaXMuX2NhbGNEaW1lbnNpb25zV2l0aFNjcm9sbCgpfSB9fSwge2tleTogXCJfY2FsY0RpbWVuc2lvbnNXaXRoU2Nyb2xsXCIsIHZhbHVlOiBmdW5jdGlvbiAoKSB7dmFyIHQgPSB0aGlzLmRpbWVuc2lvbnM7IHQuc2lkZWJhckxlZnQgPSBjLm9mZnNldFJlbGF0aXZlKHRoaXMuc2lkZWJhcikubGVmdCwgdC52aWV3cG9ydFRvcCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsIHQudmlld3BvcnRCb3R0b20gPSB0LnZpZXdwb3J0VG9wICsgdC52aWV3cG9ydEhlaWdodCwgdC52aWV3cG9ydExlZnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQsIHQudG9wU3BhY2luZyA9IHRoaXMub3B0aW9ucy50b3BTcGFjaW5nLCB0LmJvdHRvbVNwYWNpbmcgPSB0aGlzLm9wdGlvbnMuYm90dG9tU3BhY2luZywgXCJmdW5jdGlvblwiID09IHR5cGVvZiB0LnRvcFNwYWNpbmcgJiYgKHQudG9wU3BhY2luZyA9IHBhcnNlSW50KHQudG9wU3BhY2luZyh0aGlzLnNpZGViYXIpKSB8fCAwKSwgXCJmdW5jdGlvblwiID09IHR5cGVvZiB0LmJvdHRvbVNwYWNpbmcgJiYgKHQuYm90dG9tU3BhY2luZyA9IHBhcnNlSW50KHQuYm90dG9tU3BhY2luZyh0aGlzLnNpZGViYXIpKSB8fCAwKSwgXCJWSUVXUE9SVC1UT1BcIiA9PT0gdGhpcy5hZmZpeGVkVHlwZSA/IHQudG9wU3BhY2luZyA8IHQubGFzdFRvcFNwYWNpbmcgJiYgKHQudHJhbnNsYXRlWSArPSB0Lmxhc3RUb3BTcGFjaW5nIC0gdC50b3BTcGFjaW5nLCB0aGlzLl9yZVN0eWxlID0gITApIDogXCJWSUVXUE9SVC1CT1RUT01cIiA9PT0gdGhpcy5hZmZpeGVkVHlwZSAmJiB0LmJvdHRvbVNwYWNpbmcgPCB0Lmxhc3RCb3R0b21TcGFjaW5nICYmICh0LnRyYW5zbGF0ZVkgKz0gdC5sYXN0Qm90dG9tU3BhY2luZyAtIHQuYm90dG9tU3BhY2luZywgdGhpcy5fcmVTdHlsZSA9ICEwKSwgdC5sYXN0VG9wU3BhY2luZyA9IHQudG9wU3BhY2luZywgdC5sYXN0Qm90dG9tU3BhY2luZyA9IHQuYm90dG9tU3BhY2luZ319LCB7a2V5OiBcImlzU2lkZWJhckZpdHNWaWV3cG9ydFwiLCB2YWx1ZTogZnVuY3Rpb24gKCkge3ZhciB0ID0gdGhpcy5kaW1lbnNpb25zLCBlID0gXCJkb3duXCIgPT09IHRoaXMuc2Nyb2xsRGlyZWN0aW9uID8gdC5sYXN0Qm90dG9tU3BhY2luZyA6IHQubGFzdFRvcFNwYWNpbmc7IHJldHVybiB0aGlzLmRpbWVuc2lvbnMuc2lkZWJhckhlaWdodCArIGUgPCB0aGlzLmRpbWVuc2lvbnMudmlld3BvcnRIZWlnaHR9fSwge2tleTogXCJvYnNlcnZlU2Nyb2xsRGlyXCIsIHZhbHVlOiBmdW5jdGlvbiAoKSB7dmFyIHQgPSB0aGlzLmRpbWVuc2lvbnM7IGlmICh0Lmxhc3RWaWV3cG9ydFRvcCAhPT0gdC52aWV3cG9ydFRvcCkge3ZhciBlID0gXCJkb3duXCIgPT09IHRoaXMuZGlyZWN0aW9uID8gTWF0aC5taW4gOiBNYXRoLm1heDsgdC52aWV3cG9ydFRvcCA9PT0gZSh0LnZpZXdwb3J0VG9wLCB0Lmxhc3RWaWV3cG9ydFRvcCkgJiYgKHRoaXMuZGlyZWN0aW9uID0gXCJkb3duXCIgPT09IHRoaXMuZGlyZWN0aW9uID8gXCJ1cFwiIDogXCJkb3duXCIpfSB9fSwge2tleTogXCJnZXRBZmZpeFR5cGVcIiwgdmFsdWU6IGZ1bmN0aW9uICgpIHt0aGlzLl9jYWxjRGltZW5zaW9uc1dpdGhTY3JvbGwoKTsgdmFyIHQgPSB0aGlzLmRpbWVuc2lvbnMsIGUgPSB0LnZpZXdwb3J0VG9wICsgdC50b3BTcGFjaW5nLCBpID0gdGhpcy5hZmZpeGVkVHlwZTsgcmV0dXJuIGUgPD0gdC5jb250YWluZXJUb3AgfHwgdC5jb250YWluZXJIZWlnaHQgPD0gdC5zaWRlYmFySGVpZ2h0ID8gKHQudHJhbnNsYXRlWSA9IDAsIGkgPSBcIlNUQVRJQ1wiKSA6IGkgPSBcInVwXCIgPT09IHRoaXMuZGlyZWN0aW9uID8gdGhpcy5fZ2V0QWZmaXhUeXBlU2Nyb2xsaW5nVXAoKSA6IHRoaXMuX2dldEFmZml4VHlwZVNjcm9sbGluZ0Rvd24oKSwgdC50cmFuc2xhdGVZID0gTWF0aC5tYXgoMCwgdC50cmFuc2xhdGVZKSwgdC50cmFuc2xhdGVZID0gTWF0aC5taW4odC5jb250YWluZXJIZWlnaHQsIHQudHJhbnNsYXRlWSksIHQudHJhbnNsYXRlWSA9IE1hdGgucm91bmQodC50cmFuc2xhdGVZKSwgdC5sYXN0Vmlld3BvcnRUb3AgPSB0LnZpZXdwb3J0VG9wLCBpfX0sIHtrZXk6IFwiX2dldEFmZml4VHlwZVNjcm9sbGluZ0Rvd25cIiwgdmFsdWU6IGZ1bmN0aW9uICgpIHt2YXIgdCA9IHRoaXMuZGltZW5zaW9ucywgZSA9IHQuc2lkZWJhckhlaWdodCArIHQuY29udGFpbmVyVG9wLCBpID0gdC52aWV3cG9ydFRvcCArIHQudG9wU3BhY2luZywgbiA9IHQudmlld3BvcnRCb3R0b20gLSB0LmJvdHRvbVNwYWNpbmcsIG8gPSB0aGlzLmFmZml4ZWRUeXBlOyByZXR1cm4gdGhpcy5pc1NpZGViYXJGaXRzVmlld3BvcnQoKSA/IHQuc2lkZWJhckhlaWdodCArIGkgPj0gdC5jb250YWluZXJCb3R0b20gPyAodC50cmFuc2xhdGVZID0gdC5jb250YWluZXJCb3R0b20gLSBlLCBvID0gXCJDT05UQUlORVItQk9UVE9NXCIpIDogaSA+PSB0LmNvbnRhaW5lclRvcCAmJiAodC50cmFuc2xhdGVZID0gaSAtIHQuY29udGFpbmVyVG9wLCBvID0gXCJWSUVXUE9SVC1UT1BcIikgOiB0LmNvbnRhaW5lckJvdHRvbSA8PSBuID8gKHQudHJhbnNsYXRlWSA9IHQuY29udGFpbmVyQm90dG9tIC0gZSwgbyA9IFwiQ09OVEFJTkVSLUJPVFRPTVwiKSA6IGUgKyB0LnRyYW5zbGF0ZVkgPD0gbiA/ICh0LnRyYW5zbGF0ZVkgPSBuIC0gZSwgbyA9IFwiVklFV1BPUlQtQk9UVE9NXCIpIDogdC5jb250YWluZXJUb3AgKyB0LnRyYW5zbGF0ZVkgPD0gaSAmJiAwICE9PSB0LnRyYW5zbGF0ZVkgJiYgdC5tYXhUcmFuc2xhdGVZICE9PSB0LnRyYW5zbGF0ZVkgJiYgKG8gPSBcIlZJRVdQT1JULVVOQk9UVE9NXCIpLCBvfX0sIHtrZXk6IFwiX2dldEFmZml4VHlwZVNjcm9sbGluZ1VwXCIsIHZhbHVlOiBmdW5jdGlvbiAoKSB7dmFyIHQgPSB0aGlzLmRpbWVuc2lvbnMsIGUgPSB0LnNpZGViYXJIZWlnaHQgKyB0LmNvbnRhaW5lclRvcCwgaSA9IHQudmlld3BvcnRUb3AgKyB0LnRvcFNwYWNpbmcsIG4gPSB0LnZpZXdwb3J0Qm90dG9tIC0gdC5ib3R0b21TcGFjaW5nLCBvID0gdGhpcy5hZmZpeGVkVHlwZTsgcmV0dXJuIGkgPD0gdC50cmFuc2xhdGVZICsgdC5jb250YWluZXJUb3AgPyAodC50cmFuc2xhdGVZID0gaSAtIHQuY29udGFpbmVyVG9wLCBvID0gXCJWSUVXUE9SVC1UT1BcIikgOiB0LmNvbnRhaW5lckJvdHRvbSA8PSBuID8gKHQudHJhbnNsYXRlWSA9IHQuY29udGFpbmVyQm90dG9tIC0gZSwgbyA9IFwiQ09OVEFJTkVSLUJPVFRPTVwiKSA6IHRoaXMuaXNTaWRlYmFyRml0c1ZpZXdwb3J0KCkgfHwgdC5jb250YWluZXJUb3AgPD0gaSAmJiAwICE9PSB0LnRyYW5zbGF0ZVkgJiYgdC5tYXhUcmFuc2xhdGVZICE9PSB0LnRyYW5zbGF0ZVkgJiYgKG8gPSBcIlZJRVdQT1JULVVOQk9UVE9NXCIpLCBvfX0sIHtrZXk6IFwiX2dldFN0eWxlXCIsIHZhbHVlOiBmdW5jdGlvbiAodCkge2lmICh2b2lkIDAgIT09IHQpIHt2YXIgZSA9IHtpbm5lcjoge30sIG91dGVyOiB7fX0sIGkgPSB0aGlzLmRpbWVuc2lvbnM7IHN3aXRjaCAodCkge2Nhc2UgXCJWSUVXUE9SVC1UT1BcIjogZS5pbm5lciA9IHtwb3NpdGlvbjogXCJmaXhlZFwiLCB0b3A6IGkudG9wU3BhY2luZywgbGVmdDogaS5zaWRlYmFyTGVmdCAtIGkudmlld3BvcnRMZWZ0LCB3aWR0aDogaS5zaWRlYmFyV2lkdGh9OyBicmVhazsgY2FzZSBcIlZJRVdQT1JULUJPVFRPTVwiOiBlLmlubmVyID0ge3Bvc2l0aW9uOiBcImZpeGVkXCIsIHRvcDogXCJhdXRvXCIsIGxlZnQ6IGkuc2lkZWJhckxlZnQsIGJvdHRvbTogaS5ib3R0b21TcGFjaW5nLCB3aWR0aDogaS5zaWRlYmFyV2lkdGh9OyBicmVhazsgY2FzZSBcIkNPTlRBSU5FUi1CT1RUT01cIjogY2FzZSBcIlZJRVdQT1JULVVOQk9UVE9NXCI6IHZhciBuID0gdGhpcy5fZ2V0VHJhbnNsYXRlKDAsIGkudHJhbnNsYXRlWSArIFwicHhcIik7IGUuaW5uZXIgPSBuID8ge3RyYW5zZm9ybTogbn0gOiB7cG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdG9wOiBpLnRyYW5zbGF0ZVksIHdpZHRoOiBpLnNpZGViYXJXaWR0aH19c3dpdGNoICh0KSB7Y2FzZSBcIlZJRVdQT1JULVRPUFwiOiBjYXNlIFwiVklFV1BPUlQtQk9UVE9NXCI6IGNhc2UgXCJWSUVXUE9SVC1VTkJPVFRPTVwiOiBjYXNlIFwiQ09OVEFJTkVSLUJPVFRPTVwiOiBlLm91dGVyID0ge2hlaWdodDogaS5zaWRlYmFySGVpZ2h0LCBwb3NpdGlvbjogXCJyZWxhdGl2ZVwifX1yZXR1cm4gZS5vdXRlciA9IGMuZXh0ZW5kKHtoZWlnaHQ6IFwiXCIsIHBvc2l0aW9uOiBcIlwifSwgZS5vdXRlciksIGUuaW5uZXIgPSBjLmV4dGVuZCh7cG9zaXRpb246IFwicmVsYXRpdmVcIiwgdG9wOiBcIlwiLCBsZWZ0OiBcIlwiLCBib3R0b206IFwiXCIsIHdpZHRoOiBcIlwiLCB0cmFuc2Zvcm06IFwiXCJ9LCBlLmlubmVyKSwgZX0gfX0sIHtrZXk6IFwic3RpY2t5UG9zaXRpb25cIiwgdmFsdWU6IGZ1bmN0aW9uICh0KSB7aWYgKCF0aGlzLl9icmVha3BvaW50KSB7dCA9IHRoaXMuX3JlU3R5bGUgfHwgdCB8fCAhMSwgdGhpcy5vcHRpb25zLnRvcFNwYWNpbmcsIHRoaXMub3B0aW9ucy5ib3R0b21TcGFjaW5nOyB2YXIgZSA9IHRoaXMuZ2V0QWZmaXhUeXBlKCksIGkgPSB0aGlzLl9nZXRTdHlsZShlKTsgaWYgKCh0aGlzLmFmZml4ZWRUeXBlICE9IGUgfHwgdCkgJiYgZSkge3ZhciBuID0gXCJhZmZpeC5cIiArIGUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKFwidmlld3BvcnQtXCIsIFwiXCIpICsgbDsgZm9yICh2YXIgbyBpbiBjLmV2ZW50VHJpZ2dlcih0aGlzLnNpZGViYXIsIG4pLCBcIlNUQVRJQ1wiID09PSBlID8gYy5yZW1vdmVDbGFzcyh0aGlzLnNpZGViYXIsIHRoaXMub3B0aW9ucy5zdGlja3lDbGFzcykgOiBjLmFkZENsYXNzKHRoaXMuc2lkZWJhciwgdGhpcy5vcHRpb25zLnN0aWNreUNsYXNzKSwgaS5vdXRlcikge3ZhciBzID0gXCJudW1iZXJcIiA9PSB0eXBlb2YgaS5vdXRlcltvXSA/IFwicHhcIiA6IFwiXCI7IHRoaXMuc2lkZWJhci5zdHlsZVtvXSA9IGkub3V0ZXJbb10gKyBzfSBmb3IgKHZhciByIGluIGkuaW5uZXIpIHt2YXIgYSA9IFwibnVtYmVyXCIgPT0gdHlwZW9mIGkuaW5uZXJbcl0gPyBcInB4XCIgOiBcIlwiOyB0aGlzLnNpZGViYXJJbm5lci5zdHlsZVtyXSA9IGkuaW5uZXJbcl0gKyBhfSB2YXIgcCA9IFwiYWZmaXhlZC5cIiArIGUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKFwidmlld3BvcnQtXCIsIFwiXCIpICsgbDsgYy5ldmVudFRyaWdnZXIodGhpcy5zaWRlYmFyLCBwKX0gZWxzZSB0aGlzLl9pbml0aWFsaXplZCAmJiAodGhpcy5zaWRlYmFySW5uZXIuc3R5bGUubGVmdCA9IGkuaW5uZXIubGVmdCk7IHRoaXMuYWZmaXhlZFR5cGUgPSBlfSB9fSwge2tleTogXCJfd2lkdGhCcmVha3BvaW50XCIsIHZhbHVlOiBmdW5jdGlvbiAoKSB7d2luZG93LmlubmVyV2lkdGggPD0gdGhpcy5vcHRpb25zLm1pbldpZHRoID8gKHRoaXMuX2JyZWFrcG9pbnQgPSAhMCwgdGhpcy5hZmZpeGVkVHlwZSA9IFwiU1RBVElDXCIsIHRoaXMuc2lkZWJhci5yZW1vdmVBdHRyaWJ1dGUoXCJzdHlsZVwiKSwgYy5yZW1vdmVDbGFzcyh0aGlzLnNpZGViYXIsIHRoaXMub3B0aW9ucy5zdGlja3lDbGFzcyksIHRoaXMuc2lkZWJhcklubmVyLnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpKSA6IHRoaXMuX2JyZWFrcG9pbnQgPSAhMX19LCB7a2V5OiBcInVwZGF0ZVN0aWNreVwiLCB2YWx1ZTogZnVuY3Rpb24gKCkge3ZhciB0LCBlID0gdGhpcywgaSA9IDAgPCBhcmd1bWVudHMubGVuZ3RoICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzBdID8gYXJndW1lbnRzWzBdIDoge307IHRoaXMuX3J1bm5pbmcgfHwgKHRoaXMuX3J1bm5pbmcgPSAhMCwgdCA9IGkudHlwZSwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtzd2l0Y2ggKHQpIHtjYXNlIFwic2Nyb2xsXCI6IGUuX2NhbGNEaW1lbnNpb25zV2l0aFNjcm9sbCgpLCBlLm9ic2VydmVTY3JvbGxEaXIoKSwgZS5zdGlja3lQb3NpdGlvbigpOyBicmVhazsgY2FzZSBcInJlc2l6ZVwiOiBkZWZhdWx0OiBlLl93aWR0aEJyZWFrcG9pbnQoKSwgZS5jYWxjRGltZW5zaW9ucygpLCBlLnN0aWNreVBvc2l0aW9uKCEwKX1lLl9ydW5uaW5nID0gITF9KSl9fSwge2tleTogXCJfc2V0U3VwcG9ydEZlYXR1cmVzXCIsIHZhbHVlOiBmdW5jdGlvbiAoKSB7dmFyIHQgPSB0aGlzLnN1cHBvcnQ7IHQudHJhbnNmb3JtID0gYy5zdXBwb3J0VHJhbnNmb3JtKCksIHQudHJhbnNmb3JtM2QgPSBjLnN1cHBvcnRUcmFuc2Zvcm0oITApfX0sIHtrZXk6IFwiX2dldFRyYW5zbGF0ZVwiLCB2YWx1ZTogZnVuY3Rpb24gKCkge3ZhciB0ID0gMCA8IGFyZ3VtZW50cy5sZW5ndGggJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMF0gPyBhcmd1bWVudHNbMF0gOiAwLCBlID0gMSA8IGFyZ3VtZW50cy5sZW5ndGggJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMV0gPyBhcmd1bWVudHNbMV0gOiAwLCBpID0gMiA8IGFyZ3VtZW50cy5sZW5ndGggJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMl0gPyBhcmd1bWVudHNbMl0gOiAwOyByZXR1cm4gdGhpcy5zdXBwb3J0LnRyYW5zZm9ybTNkID8gXCJ0cmFuc2xhdGUzZChcIiArIHQgKyBcIiwgXCIgKyBlICsgXCIsIFwiICsgaSArIFwiKVwiIDogISF0aGlzLnN1cHBvcnQudHJhbnNsYXRlICYmIFwidHJhbnNsYXRlKFwiICsgdCArIFwiLCBcIiArIGUgKyBcIilcIn19LCB7a2V5OiBcImRlc3Ryb3lcIiwgdmFsdWU6IGZ1bmN0aW9uICgpIHt3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLCB7Y2FwdHVyZTogITF9KSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcywge2NhcHR1cmU6ICExfSksIHRoaXMuc2lkZWJhci5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5zdGlja3lDbGFzcyksIHRoaXMuc2lkZWJhci5zdHlsZS5taW5IZWlnaHQgPSBcIlwiLCB0aGlzLnNpZGViYXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInVwZGF0ZVwiICsgbCwgdGhpcyk7IHZhciB0ID0ge2lubmVyOiB7fSwgb3V0ZXI6IHt9fTsgZm9yICh2YXIgZSBpbiB0LmlubmVyID0ge3Bvc2l0aW9uOiBcIlwiLCB0b3A6IFwiXCIsIGxlZnQ6IFwiXCIsIGJvdHRvbTogXCJcIiwgd2lkdGg6IFwiXCIsIHRyYW5zZm9ybTogXCJcIn0sIHQub3V0ZXIgPSB7aGVpZ2h0OiBcIlwiLCBwb3NpdGlvbjogXCJcIn0sIHQub3V0ZXIpIHRoaXMuc2lkZWJhci5zdHlsZVtlXSA9IHQub3V0ZXJbZV07IGZvciAodmFyIGkgaW4gdC5pbm5lcikgdGhpcy5zaWRlYmFySW5uZXIuc3R5bGVbaV0gPSB0LmlubmVyW2ldOyB0aGlzLm9wdGlvbnMucmVzaXplU2Vuc29yICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFJlc2l6ZVNlbnNvciAmJiAoUmVzaXplU2Vuc29yLmRldGFjaCh0aGlzLnNpZGViYXJJbm5lciwgdGhpcy5oYW5kbGVFdmVudCksIFJlc2l6ZVNlbnNvci5kZXRhY2godGhpcy5jb250YWluZXIsIHRoaXMuaGFuZGxlRXZlbnQpKX19XSwgW3trZXk6IFwic3VwcG9ydFRyYW5zZm9ybVwiLCB2YWx1ZTogZnVuY3Rpb24gKHQpIHt2YXIgaSA9ICExLCBlID0gdCA/IFwicGVyc3BlY3RpdmVcIiA6IFwidHJhbnNmb3JtXCIsIG4gPSBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgZS5zbGljZSgxKSwgbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdXBwb3J0XCIpLnN0eWxlOyByZXR1cm4gKGUgKyBcIiBcIiArIFtcIldlYmtpdFwiLCBcIk1velwiLCBcIk9cIiwgXCJtc1wiXS5qb2luKG4gKyBcIiBcIikgKyBuKS5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbiAodCwgZSkge2lmICh2b2lkIDAgIT09IG9bdF0pIHJldHVybiBpID0gdCwgITF9KSwgaX19LCB7a2V5OiBcImV2ZW50VHJpZ2dlclwiLCB2YWx1ZTogZnVuY3Rpb24gKHQsIGUsIGkpIHt0cnkge3ZhciBuID0gbmV3IEN1c3RvbUV2ZW50KGUsIHtkZXRhaWw6IGl9KX0gY2F0Y2ggKHQpIHsobiA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIikpLmluaXRDdXN0b21FdmVudChlLCAhMCwgITAsIGkpfSB0LmRpc3BhdGNoRXZlbnQobil9fSwge2tleTogXCJleHRlbmRcIiwgdmFsdWU6IGZ1bmN0aW9uICh0LCBlKSB7dmFyIGkgPSB7fTsgZm9yICh2YXIgbiBpbiB0KSB2b2lkIDAgIT09IGVbbl0gPyBpW25dID0gZVtuXSA6IGlbbl0gPSB0W25dOyByZXR1cm4gaX19LCB7a2V5OiBcIm9mZnNldFJlbGF0aXZlXCIsIHZhbHVlOiBmdW5jdGlvbiAodCkge3ZhciBlID0ge2xlZnQ6IDAsIHRvcDogMH07IGRvIHt2YXIgaSA9IHQub2Zmc2V0VG9wLCBuID0gdC5vZmZzZXRMZWZ0OyBpc05hTihpKSB8fCAoZS50b3AgKz0gaSksIGlzTmFOKG4pIHx8IChlLmxlZnQgKz0gbiksIHQgPSBcIkJPRFlcIiA9PT0gdC50YWdOYW1lID8gdC5wYXJlbnRFbGVtZW50IDogdC5vZmZzZXRQYXJlbnR9IHdoaWxlICh0KTsgcmV0dXJuIGV9fSwge2tleTogXCJhZGRDbGFzc1wiLCB2YWx1ZTogZnVuY3Rpb24gKHQsIGUpIHtjLmhhc0NsYXNzKHQsIGUpIHx8ICh0LmNsYXNzTGlzdCA/IHQuY2xhc3NMaXN0LmFkZChlKSA6IHQuY2xhc3NOYW1lICs9IFwiIFwiICsgZSl9fSwge2tleTogXCJyZW1vdmVDbGFzc1wiLCB2YWx1ZTogZnVuY3Rpb24gKHQsIGUpIHtjLmhhc0NsYXNzKHQsIGUpICYmICh0LmNsYXNzTGlzdCA/IHQuY2xhc3NMaXN0LnJlbW92ZShlKSA6IHQuY2xhc3NOYW1lID0gdC5jbGFzc05hbWUucmVwbGFjZShuZXcgUmVnRXhwKFwiKF58XFxcXGIpXCIgKyBlLnNwbGl0KFwiIFwiKS5qb2luKFwifFwiKSArIFwiKFxcXFxifCQpXCIsIFwiZ2lcIiksIFwiIFwiKSl9fSwge2tleTogXCJoYXNDbGFzc1wiLCB2YWx1ZTogZnVuY3Rpb24gKHQsIGUpIHtyZXR1cm4gdC5jbGFzc0xpc3QgPyB0LmNsYXNzTGlzdC5jb250YWlucyhlKSA6IG5ldyBSZWdFeHAoXCIoXnwgKVwiICsgZSArIFwiKCB8JClcIiwgXCJnaVwiKS50ZXN0KHQuY2xhc3NOYW1lKX19LCB7a2V5OiBcImRlZmF1bHRzXCIsIGdldDogZnVuY3Rpb24gKCkge3JldHVybiBufX1dKSwgY30oKSk7IHQuZGVmYXVsdCA9IGksIHdpbmRvdy5TdGlja3lTaWRlYmFyID0gaX0pKGUpfShlID0ge2V4cG9ydHM6IHt9fSwgZS5leHBvcnRzKSwgZS5leHBvcnRzKSwgbyA9IChpID0gbikgJiYgaS5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpLCBcImRlZmF1bHRcIikgPyBpLmRlZmF1bHQgOiBpOyB0LmRlZmF1bHQgPSBvLCB0Ll9fbW9kdWxlRXhwb3J0cyA9IG4sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiAhMH0pfSk7XG5cbmlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuanMtc3RpY2t5LXNpZGViYXInKSkge1xuICAgIHZhciBzaWRlYmFyID0gbmV3IFN0aWNreVNpZGViYXIoJy5qcy1zdGlja3ktc2lkZWJhcicsIHtcbiAgICAgICAgdG9wU3BhY2luZzogMjAsXG4gICAgICAgIGJvdHRvbVNwYWNpbmc6IDIwLFxuICAgICAgICBjb250YWluZXJTZWxlY3RvcjogJy5qcy1zdGlja3ktbWFpbi1jb250ZW50JyxcbiAgICAgICAgaW5uZXJXcmFwcGVyU2VsZWN0b3I6ICcuanMtc3RpY2t5LXNpZGViYXJfX2lubmVyJyxcbiAgICAgICAgbWluV2lkdGg6IDEwMjRcbiAgICB9KTtcbn1cbiJdfQ==
