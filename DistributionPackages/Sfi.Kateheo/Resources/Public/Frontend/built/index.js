document.querySelectorAll("a.js-TagsListBtn").forEach(el => {
    el.addEventListener("click", function(event){
        event.preventDefault();
        // start spinning
        document.querySelectorAll('.js-TagsListIcon').forEach(el => {
            el.classList.add('isSpinning');
        });

        fetch('/?showAllTags=true').then(response => response.text()).then(html => {
            document.querySelectorAll('.js-TagsList').forEach(el => {
                el.innerHTML = html + '<br><br>';
            });
        });
    }, false);
});

!function (e, t) {if ("object" == typeof exports && "object" == typeof module) module.exports = t(); else if ("function" == typeof define && define.amd) define([], t); else {var n = t(); for (var i in n) ("object" == typeof exports ? exports : e)[i] = n[i]} }(this, function () {return function (e) {function t(i) {if (n[i]) return n[i].exports; var o = n[i] = {exports: {}, id: i, loaded: !1}; return e[i].call(o.exports, o, o.exports, t), o.loaded = !0, o.exports} var n = {}; return t.m = e, t.c = n, t.p = "", t(0)}([function (e, t, n) {e.exports = n(1)}, function (e, t, n) {"use strict"; function i(e) {return e && e.__esModule ? e : {"default": e}} function o(e, t) {function n(e, t) {var n = z, i = n.classNameActiveSlide; e.forEach(function (e, t) {e.classList.contains(i) && e.classList.remove(i)}), e[t].classList.add(i)} function i(e) {var t = z, n = t.infinite, i = e.slice(0, n), o = e.slice(e.length - n, e.length); return i.forEach(function (e) {var t = e.cloneNode(!0); B.appendChild(t)}), o.reverse().forEach(function (e) {var t = e.cloneNode(!0); B.insertBefore(t, B.firstChild)}), B.addEventListener(O.transitionEnd, y), f.call(B.children)} function o(t, n, i) {(0, l["default"])(e, t + ".lory." + n, i)} function a(e, t, n) {var i = B && B.style; i && (i[O.transition + "TimingFunction"] = n, i[O.transition + "Duration"] = t + "ms", O.hasTranslate3d ? i[O.transform] = "translate3d(" + e + "px, 0, 0)" : i[O.transform] = "translate(" + e + "px, 0)")} function d(e, t) {var i = z, r = i.slideSpeed, s = i.slidesToScroll, d = i.infinite, l = i.rewind, c = i.rewindSpeed, u = i.ease, v = i.classNameActiveSlide, m = r, p = t ? P + 1 : P - 1, h = Math.round(M - S); o("before", "slide", {index: P, nextSlide: p}), "number" != typeof e && (e = t ? P + s : P - s), e = Math.min(Math.max(e, 0), _.length - 1), d && void 0 === t && (e += d); var E = Math.min(Math.max(_[e].offsetLeft * -1, h * -1), 0); l && Math.abs(N.x) === h && t && (E = 0, e = 0, m = c), a(E, m, u), N.x = E, _[e].offsetLeft <= h && (P = e), !d || e !== _.length - d && 0 !== e || (t && (P = d), t || (P = _.length - 2 * d), N.x = _[P].offsetLeft * -1, A = function () {a(_[P].offsetLeft * -1, 0, void 0)}), v && n(f.call(_), P), o("after", "slide", {currentSlide: P})} function c() {o("before", "init"), O = (0, s["default"])(), z = r({}, u["default"], t); var a = z, d = a.classNameFrame, l = a.classNameSlideContainer, c = a.classNamePrevCtrl, m = a.classNameNextCtrl, p = a.enableMouseEvents, b = a.classNameActiveSlide; j = e.getElementsByClassName(d)[0], B = j.getElementsByClassName(l)[0], k = e.getElementsByClassName(c)[0], T = e.getElementsByClassName(m)[0], N = {x: B.offsetLeft, y: B.offsetTop}, _ = z.infinite ? i(f.call(B.children)) : f.call(B.children), v(), b && n(_, P), k && T && (k.addEventListener("click", h), T.addEventListener("click", E)), j.addEventListener("touchstart", x), p && (j.addEventListener("mousedown", x), j.addEventListener("click", g)), z.window.addEventListener("resize", C), o("after", "init")} function v() {var e = z, t = e.infinite, i = e.ease, o = e.rewindSpeed, r = e.rewindOnResize, s = e.classNameActiveSlide; M = B.getBoundingClientRect().width || B.offsetWidth, S = j.getBoundingClientRect().width || j.offsetWidth, S === M && (M = _.reduce(function (e, t) {return e + t.getBoundingClientRect().width || t.offsetWidth}, 0)), r ? P = 0 : (i = null, o = 0), t ? (a(_[P + t].offsetLeft * -1, 0, null), P += t, N.x = _[P].offsetLeft * -1) : (a(_[P].offsetLeft * -1, o, i), N.x = _[P].offsetLeft * -1), s && n(f.call(_), P)} function m(e) {d(e)} function p() {return P - z.infinite || 0} function h() {d(!1, !1)} function E() {d(!1, !0)} function b() {o("before", "destroy"), j.removeEventListener(O.transitionEnd, y), j.removeEventListener("touchstart", x), j.removeEventListener("touchmove", L), j.removeEventListener("touchend", w), j.removeEventListener("mousemove", L), j.removeEventListener("mousedown", x), j.removeEventListener("mouseup", w), j.removeEventListener("mouseleave", w), j.removeEventListener("click", g), z.window.removeEventListener("resize", C), k && k.removeEventListener("click", h), T && T.removeEventListener("click", E), z.infinite && Array.apply(null, Array(z.infinite)).forEach(function () {B.removeChild(B.firstChild), B.removeChild(B.lastChild)}), o("after", "destroy")} function y() {A && (A(), A = void 0)} function x(e) {var t = z, n = t.enableMouseEvents, i = e.touches ? e.touches[0] : e; n && (j.addEventListener("mousemove", L), j.addEventListener("mouseup", w), j.addEventListener("mouseleave", w)), j.addEventListener("touchmove", L), j.addEventListener("touchend", w); var r = i.pageX, a = i.pageY; D = {x: r, y: a, time: Date.now()}, F = void 0, R = {}, o("on", "touchstart", {event: e})} function L(e) {var t = e.touches ? e.touches[0] : e, n = t.pageX, i = t.pageY; R = {x: n - D.x, y: i - D.y}, "undefined" == typeof F && (F = !!(F || Math.abs(R.x) < Math.abs(R.y))), !F && D && (e.preventDefault(), a(N.x + R.x, 0, null)), o("on", "touchmove", {event: e})} function w(e) {var t = D ? Date.now() - D.time : void 0, n = Number(t) < 300 && Math.abs(R.x) > 25 || Math.abs(R.x) > S / 3, i = !P && R.x > 0 || P === _.length - 1 && R.x < 0, r = R.x < 0; F || (n && !i ? d(!1, r) : a(N.x, z.snapBackSpeed)), D = void 0, j.removeEventListener("touchmove", L), j.removeEventListener("touchend", w), j.removeEventListener("mousemove", L), j.removeEventListener("mouseup", w), j.removeEventListener("mouseleave", w), o("on", "touchend", {event: e})} function g(e) {R.x && e.preventDefault()} function C(e) {v(), o("on", "resize", {event: e})} var N = void 0, M = void 0, S = void 0, _ = void 0, j = void 0, B = void 0, k = void 0, T = void 0, O = void 0, A = void 0, P = 0, z = {}; "undefined" != typeof jQuery && e instanceof jQuery && (e = e[0]); var D = void 0, R = void 0, F = void 0; return c(), {setup: c, reset: v, slideTo: m, returnIndex: p, prev: h, next: E, destroy: b}} Object.defineProperty(t, "__esModule", {value: !0}); var r = Object.assign || function (e) {for (var t = 1; t < arguments.length; t++) {var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])} return e}; t.lory = o; var a = n(2), s = i(a), d = n(3), l = i(d), c = n(5), u = i(c), f = Array.prototype.slice}, function (e, t) {(function (e) {"use strict"; function n() {var t = void 0, n = void 0, i = void 0, o = void 0; return function () {var r = document.createElement("_"), a = r.style, s = void 0; "" === a[s = "webkitTransition"] && (i = "webkitTransitionEnd", n = s), "" === a[s = "transition"] && (i = "transitionend", n = s), "" === a[s = "webkitTransform"] && (t = s), "" === a[s = "msTransform"] && (t = s), "" === a[s = "transform"] && (t = s), document.body.insertBefore(r, null), a[t] = "translate3d(0, 0, 0)", o = !!e.getComputedStyle(r).getPropertyValue(t), document.body.removeChild(r)}(), {transform: t, transition: n, transitionEnd: i, hasTranslate3d: o}} Object.defineProperty(t, "__esModule", {value: !0}), t["default"] = n}).call(t, function () {return this}())}, function (e, t, n) {"use strict"; function i(e) {return e && e.__esModule ? e : {"default": e}} function o(e, t, n) {var i = new a["default"](t, {bubbles: !0, cancelable: !0, detail: n}); e.dispatchEvent(i)} Object.defineProperty(t, "__esModule", {value: !0}), t["default"] = o; var r = n(4), a = i(r)}, function (e, t) {(function (t) {function n() {try {var e = new i("cat", {detail: {foo: "bar"}}); return "cat" === e.type && "bar" === e.detail.foo} catch (t) {} return !1} var i = t.CustomEvent; e.exports = n() ? i : "function" == typeof document.createEvent ? function (e, t) {var n = document.createEvent("CustomEvent"); return t ? n.initCustomEvent(e, t.bubbles, t.cancelable, t.detail) : n.initCustomEvent(e, !1, !1, void 0), n} : function (e, t) {var n = document.createEventObject(); return n.type = e, t ? (n.bubbles = Boolean(t.bubbles), n.cancelable = Boolean(t.cancelable), n.detail = t.detail) : (n.bubbles = !1, n.cancelable = !1, n.detail = void 0), n}}).call(t, function () {return this}())}, function (e, t) {"use strict"; Object.defineProperty(t, "__esModule", {value: !0}), t["default"] = {slidesToScroll: 1, slideSpeed: 300, rewindSpeed: 600, snapBackSpeed: 200, ease: "ease", rewind: !1, infinite: !1, classNameFrame: "js_frame", classNameSlideContainer: "js_slides", classNamePrevCtrl: "js_prev", classNameNextCtrl: "js_next", classNameActiveSlide: "active", enableMouseEvents: !1, window: window, rewindOnResize: !0}}])});

(function () {

    function Carousel(el) {
        var instance = lory(el, {
            infinite: 1,
            enableMouseEvents: true
        });
    }

    // Shuffle Carousel
    [].slice.call(document.querySelectorAll('[data-carousel]')).forEach(function (el) {
        var ul = el.querySelector('ul');
        for (var i = ul.children.length; i >= 0; i--) {
            ul.appendChild(ul.children[Math.random() * i | 0]);
        }
        Carousel(el);
    });
})();

/**
 * sticky-sidebar - A JavaScript plugin for making smart and high performance.
 * @version v3.3.1
 * @link https://github.com/abouolia/sticky-sidebar
 * @author Ahmed Bouhuolia
 * @license The MIT License (MIT)
**/
!function (t, e) {"object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e(t.StickySidebar = {})}(this, function (t) {"use strict"; "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self && self; var e, i, n = (function (t, e) {(function (t) {Object.defineProperty(t, "__esModule", {value: !0}); var l, n, e = function () {function n(t, e) {for (var i = 0; i < e.length; i++) {var n = e[i]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)} } return function (t, e, i) {return e && n(t.prototype, e), i && n(t, i), t}}(), i = (l = ".stickySidebar", n = {topSpacing: 0, bottomSpacing: 0, containerSelector: !1, innerWrapperSelector: ".inner-wrapper-sticky", stickyClass: "is-affixed", resizeSensor: !0, minWidth: !1}, function () {function c(t) {var e = this, i = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}; if (function (t, e) {if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")}(this, c), this.options = c.extend(n, i), this.sidebar = "string" == typeof t ? document.querySelector(t) : t, void 0 === this.sidebar) throw new Error("There is no specific sidebar element."); this.sidebarInner = !1, this.container = this.sidebar.parentElement, this.affixedType = "STATIC", this.direction = "down", this.support = {transform: !1, transform3d: !1}, this._initialized = !1, this._reStyle = !1, this._breakpoint = !1, this.dimensions = {translateY: 0, maxTranslateY: 0, topSpacing: 0, lastTopSpacing: 0, bottomSpacing: 0, lastBottomSpacing: 0, sidebarHeight: 0, sidebarWidth: 0, containerTop: 0, containerHeight: 0, viewportHeight: 0, viewportTop: 0, lastViewportTop: 0}, ["handleEvent"].forEach(function (t) {e[t] = e[t].bind(e)}), this.initialize()} return e(c, [{key: "initialize", value: function () {var i = this; if (this._setSupportFeatures(), this.options.innerWrapperSelector && (this.sidebarInner = this.sidebar.querySelector(this.options.innerWrapperSelector), null === this.sidebarInner && (this.sidebarInner = !1)), !this.sidebarInner) {var t = document.createElement("div"); for (t.setAttribute("class", "inner-wrapper-sticky"), this.sidebar.appendChild(t); this.sidebar.firstChild != t;)t.appendChild(this.sidebar.firstChild); this.sidebarInner = this.sidebar.querySelector(".inner-wrapper-sticky")} if (this.options.containerSelector) {var e = document.querySelectorAll(this.options.containerSelector); if ((e = Array.prototype.slice.call(e)).forEach(function (t, e) {t.contains(i.sidebar) && (i.container = t)}), !e.length) throw new Error("The container does not contains on the sidebar.")} "function" != typeof this.options.topSpacing && (this.options.topSpacing = parseInt(this.options.topSpacing) || 0), "function" != typeof this.options.bottomSpacing && (this.options.bottomSpacing = parseInt(this.options.bottomSpacing) || 0), this._widthBreakpoint(), this.calcDimensions(), this.stickyPosition(), this.bindEvents(), this._initialized = !0}}, {key: "bindEvents", value: function () {window.addEventListener("resize", this, {passive: !0, capture: !1}), window.addEventListener("scroll", this, {passive: !0, capture: !1}), this.sidebar.addEventListener("update" + l, this), this.options.resizeSensor && "undefined" != typeof ResizeSensor && (new ResizeSensor(this.sidebarInner, this.handleEvent), new ResizeSensor(this.container, this.handleEvent))}}, {key: "handleEvent", value: function (t) {this.updateSticky(t)}}, {key: "calcDimensions", value: function () {if (!this._breakpoint) {var t = this.dimensions; t.containerTop = c.offsetRelative(this.container).top, t.containerHeight = this.container.clientHeight, t.containerBottom = t.containerTop + t.containerHeight, t.sidebarHeight = this.sidebarInner.offsetHeight, t.sidebarWidth = this.sidebarInner.offsetWidth, t.viewportHeight = window.innerHeight, t.maxTranslateY = t.containerHeight - t.sidebarHeight, this._calcDimensionsWithScroll()} }}, {key: "_calcDimensionsWithScroll", value: function () {var t = this.dimensions; t.sidebarLeft = c.offsetRelative(this.sidebar).left, t.viewportTop = document.documentElement.scrollTop || document.body.scrollTop, t.viewportBottom = t.viewportTop + t.viewportHeight, t.viewportLeft = document.documentElement.scrollLeft || document.body.scrollLeft, t.topSpacing = this.options.topSpacing, t.bottomSpacing = this.options.bottomSpacing, "function" == typeof t.topSpacing && (t.topSpacing = parseInt(t.topSpacing(this.sidebar)) || 0), "function" == typeof t.bottomSpacing && (t.bottomSpacing = parseInt(t.bottomSpacing(this.sidebar)) || 0), "VIEWPORT-TOP" === this.affixedType ? t.topSpacing < t.lastTopSpacing && (t.translateY += t.lastTopSpacing - t.topSpacing, this._reStyle = !0) : "VIEWPORT-BOTTOM" === this.affixedType && t.bottomSpacing < t.lastBottomSpacing && (t.translateY += t.lastBottomSpacing - t.bottomSpacing, this._reStyle = !0), t.lastTopSpacing = t.topSpacing, t.lastBottomSpacing = t.bottomSpacing}}, {key: "isSidebarFitsViewport", value: function () {var t = this.dimensions, e = "down" === this.scrollDirection ? t.lastBottomSpacing : t.lastTopSpacing; return this.dimensions.sidebarHeight + e < this.dimensions.viewportHeight}}, {key: "observeScrollDir", value: function () {var t = this.dimensions; if (t.lastViewportTop !== t.viewportTop) {var e = "down" === this.direction ? Math.min : Math.max; t.viewportTop === e(t.viewportTop, t.lastViewportTop) && (this.direction = "down" === this.direction ? "up" : "down")} }}, {key: "getAffixType", value: function () {this._calcDimensionsWithScroll(); var t = this.dimensions, e = t.viewportTop + t.topSpacing, i = this.affixedType; return e <= t.containerTop || t.containerHeight <= t.sidebarHeight ? (t.translateY = 0, i = "STATIC") : i = "up" === this.direction ? this._getAffixTypeScrollingUp() : this._getAffixTypeScrollingDown(), t.translateY = Math.max(0, t.translateY), t.translateY = Math.min(t.containerHeight, t.translateY), t.translateY = Math.round(t.translateY), t.lastViewportTop = t.viewportTop, i}}, {key: "_getAffixTypeScrollingDown", value: function () {var t = this.dimensions, e = t.sidebarHeight + t.containerTop, i = t.viewportTop + t.topSpacing, n = t.viewportBottom - t.bottomSpacing, o = this.affixedType; return this.isSidebarFitsViewport() ? t.sidebarHeight + i >= t.containerBottom ? (t.translateY = t.containerBottom - e, o = "CONTAINER-BOTTOM") : i >= t.containerTop && (t.translateY = i - t.containerTop, o = "VIEWPORT-TOP") : t.containerBottom <= n ? (t.translateY = t.containerBottom - e, o = "CONTAINER-BOTTOM") : e + t.translateY <= n ? (t.translateY = n - e, o = "VIEWPORT-BOTTOM") : t.containerTop + t.translateY <= i && 0 !== t.translateY && t.maxTranslateY !== t.translateY && (o = "VIEWPORT-UNBOTTOM"), o}}, {key: "_getAffixTypeScrollingUp", value: function () {var t = this.dimensions, e = t.sidebarHeight + t.containerTop, i = t.viewportTop + t.topSpacing, n = t.viewportBottom - t.bottomSpacing, o = this.affixedType; return i <= t.translateY + t.containerTop ? (t.translateY = i - t.containerTop, o = "VIEWPORT-TOP") : t.containerBottom <= n ? (t.translateY = t.containerBottom - e, o = "CONTAINER-BOTTOM") : this.isSidebarFitsViewport() || t.containerTop <= i && 0 !== t.translateY && t.maxTranslateY !== t.translateY && (o = "VIEWPORT-UNBOTTOM"), o}}, {key: "_getStyle", value: function (t) {if (void 0 !== t) {var e = {inner: {}, outer: {}}, i = this.dimensions; switch (t) {case "VIEWPORT-TOP": e.inner = {position: "fixed", top: i.topSpacing, left: i.sidebarLeft - i.viewportLeft, width: i.sidebarWidth}; break; case "VIEWPORT-BOTTOM": e.inner = {position: "fixed", top: "auto", left: i.sidebarLeft, bottom: i.bottomSpacing, width: i.sidebarWidth}; break; case "CONTAINER-BOTTOM": case "VIEWPORT-UNBOTTOM": var n = this._getTranslate(0, i.translateY + "px"); e.inner = n ? {transform: n} : {position: "absolute", top: i.translateY, width: i.sidebarWidth}}switch (t) {case "VIEWPORT-TOP": case "VIEWPORT-BOTTOM": case "VIEWPORT-UNBOTTOM": case "CONTAINER-BOTTOM": e.outer = {height: i.sidebarHeight, position: "relative"}}return e.outer = c.extend({height: "", position: ""}, e.outer), e.inner = c.extend({position: "relative", top: "", left: "", bottom: "", width: "", transform: ""}, e.inner), e} }}, {key: "stickyPosition", value: function (t) {if (!this._breakpoint) {t = this._reStyle || t || !1, this.options.topSpacing, this.options.bottomSpacing; var e = this.getAffixType(), i = this._getStyle(e); if ((this.affixedType != e || t) && e) {var n = "affix." + e.toLowerCase().replace("viewport-", "") + l; for (var o in c.eventTrigger(this.sidebar, n), "STATIC" === e ? c.removeClass(this.sidebar, this.options.stickyClass) : c.addClass(this.sidebar, this.options.stickyClass), i.outer) {var s = "number" == typeof i.outer[o] ? "px" : ""; this.sidebar.style[o] = i.outer[o] + s} for (var r in i.inner) {var a = "number" == typeof i.inner[r] ? "px" : ""; this.sidebarInner.style[r] = i.inner[r] + a} var p = "affixed." + e.toLowerCase().replace("viewport-", "") + l; c.eventTrigger(this.sidebar, p)} else this._initialized && (this.sidebarInner.style.left = i.inner.left); this.affixedType = e} }}, {key: "_widthBreakpoint", value: function () {window.innerWidth <= this.options.minWidth ? (this._breakpoint = !0, this.affixedType = "STATIC", this.sidebar.removeAttribute("style"), c.removeClass(this.sidebar, this.options.stickyClass), this.sidebarInner.removeAttribute("style")) : this._breakpoint = !1}}, {key: "updateSticky", value: function () {var t, e = this, i = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {}; this._running || (this._running = !0, t = i.type, requestAnimationFrame(function () {switch (t) {case "scroll": e._calcDimensionsWithScroll(), e.observeScrollDir(), e.stickyPosition(); break; case "resize": default: e._widthBreakpoint(), e.calcDimensions(), e.stickyPosition(!0)}e._running = !1}))}}, {key: "_setSupportFeatures", value: function () {var t = this.support; t.transform = c.supportTransform(), t.transform3d = c.supportTransform(!0)}}, {key: "_getTranslate", value: function () {var t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0; return this.support.transform3d ? "translate3d(" + t + ", " + e + ", " + i + ")" : !!this.support.translate && "translate(" + t + ", " + e + ")"}}, {key: "destroy", value: function () {window.removeEventListener("resize", this, {capture: !1}), window.removeEventListener("scroll", this, {capture: !1}), this.sidebar.classList.remove(this.options.stickyClass), this.sidebar.style.minHeight = "", this.sidebar.removeEventListener("update" + l, this); var t = {inner: {}, outer: {}}; for (var e in t.inner = {position: "", top: "", left: "", bottom: "", width: "", transform: ""}, t.outer = {height: "", position: ""}, t.outer) this.sidebar.style[e] = t.outer[e]; for (var i in t.inner) this.sidebarInner.style[i] = t.inner[i]; this.options.resizeSensor && "undefined" != typeof ResizeSensor && (ResizeSensor.detach(this.sidebarInner, this.handleEvent), ResizeSensor.detach(this.container, this.handleEvent))}}], [{key: "supportTransform", value: function (t) {var i = !1, e = t ? "perspective" : "transform", n = e.charAt(0).toUpperCase() + e.slice(1), o = document.createElement("support").style; return (e + " " + ["Webkit", "Moz", "O", "ms"].join(n + " ") + n).split(" ").forEach(function (t, e) {if (void 0 !== o[t]) return i = t, !1}), i}}, {key: "eventTrigger", value: function (t, e, i) {try {var n = new CustomEvent(e, {detail: i})} catch (t) {(n = document.createEvent("CustomEvent")).initCustomEvent(e, !0, !0, i)} t.dispatchEvent(n)}}, {key: "extend", value: function (t, e) {var i = {}; for (var n in t) void 0 !== e[n] ? i[n] = e[n] : i[n] = t[n]; return i}}, {key: "offsetRelative", value: function (t) {var e = {left: 0, top: 0}; do {var i = t.offsetTop, n = t.offsetLeft; isNaN(i) || (e.top += i), isNaN(n) || (e.left += n), t = "BODY" === t.tagName ? t.parentElement : t.offsetParent} while (t); return e}}, {key: "addClass", value: function (t, e) {c.hasClass(t, e) || (t.classList ? t.classList.add(e) : t.className += " " + e)}}, {key: "removeClass", value: function (t, e) {c.hasClass(t, e) && (t.classList ? t.classList.remove(e) : t.className = t.className.replace(new RegExp("(^|\\b)" + e.split(" ").join("|") + "(\\b|$)", "gi"), " "))}}, {key: "hasClass", value: function (t, e) {return t.classList ? t.classList.contains(e) : new RegExp("(^| )" + e + "( |$)", "gi").test(t.className)}}, {key: "defaults", get: function () {return n}}]), c}()); t.default = i, window.StickySidebar = i})(e)}(e = {exports: {}}, e.exports), e.exports), o = (i = n) && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i; t.default = o, t.__moduleExports = n, Object.defineProperty(t, "__esModule", {value: !0})});

if (document.querySelector('.js-sticky-sidebar')) {
    var sidebar = new StickySidebar('.js-sticky-sidebar', {
        topSpacing: 20,
        bottomSpacing: 20,
        containerSelector: '.js-sticky-main-content',
        innerWrapperSelector: '.js-sticky-sidebar__inner',
        minWidth: 1024
    });
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRhZ3MuanMiLCJ2ZW5kb3ItbG9yeS5qcyIsInZlbmRvci1zdGlja3kuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiYS5qcy1UYWdzTGlzdEJ0blwiKS5mb3JFYWNoKGVsID0+IHtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAvLyBzdGFydCBzcGlubmluZ1xuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuanMtVGFnc0xpc3RJY29uJykuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdpc1NwaW5uaW5nJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZldGNoKCcvP3Nob3dBbGxUYWdzPXRydWUnKS50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLnRleHQoKSkudGhlbihodG1sID0+IHtcbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5qcy1UYWdzTGlzdCcpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IGh0bWwgKyAnPGJyPjxicj4nO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sIGZhbHNlKTtcbn0pO1xuIiwiIWZ1bmN0aW9uIChlLCB0KSB7aWYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIGV4cG9ydHMgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgbW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IHQoKTsgZWxzZSBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBkZWZpbmUgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKFtdLCB0KTsgZWxzZSB7dmFyIG4gPSB0KCk7IGZvciAodmFyIGkgaW4gbikgKFwib2JqZWN0XCIgPT0gdHlwZW9mIGV4cG9ydHMgPyBleHBvcnRzIDogZSlbaV0gPSBuW2ldfSB9KHRoaXMsIGZ1bmN0aW9uICgpIHtyZXR1cm4gZnVuY3Rpb24gKGUpIHtmdW5jdGlvbiB0KGkpIHtpZiAobltpXSkgcmV0dXJuIG5baV0uZXhwb3J0czsgdmFyIG8gPSBuW2ldID0ge2V4cG9ydHM6IHt9LCBpZDogaSwgbG9hZGVkOiAhMX07IHJldHVybiBlW2ldLmNhbGwoby5leHBvcnRzLCBvLCBvLmV4cG9ydHMsIHQpLCBvLmxvYWRlZCA9ICEwLCBvLmV4cG9ydHN9IHZhciBuID0ge307IHJldHVybiB0Lm0gPSBlLCB0LmMgPSBuLCB0LnAgPSBcIlwiLCB0KDApfShbZnVuY3Rpb24gKGUsIHQsIG4pIHtlLmV4cG9ydHMgPSBuKDEpfSwgZnVuY3Rpb24gKGUsIHQsIG4pIHtcInVzZSBzdHJpY3RcIjsgZnVuY3Rpb24gaShlKSB7cmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHtcImRlZmF1bHRcIjogZX19IGZ1bmN0aW9uIG8oZSwgdCkge2Z1bmN0aW9uIG4oZSwgdCkge3ZhciBuID0geiwgaSA9IG4uY2xhc3NOYW1lQWN0aXZlU2xpZGU7IGUuZm9yRWFjaChmdW5jdGlvbiAoZSwgdCkge2UuY2xhc3NMaXN0LmNvbnRhaW5zKGkpICYmIGUuY2xhc3NMaXN0LnJlbW92ZShpKX0pLCBlW3RdLmNsYXNzTGlzdC5hZGQoaSl9IGZ1bmN0aW9uIGkoZSkge3ZhciB0ID0geiwgbiA9IHQuaW5maW5pdGUsIGkgPSBlLnNsaWNlKDAsIG4pLCBvID0gZS5zbGljZShlLmxlbmd0aCAtIG4sIGUubGVuZ3RoKTsgcmV0dXJuIGkuZm9yRWFjaChmdW5jdGlvbiAoZSkge3ZhciB0ID0gZS5jbG9uZU5vZGUoITApOyBCLmFwcGVuZENoaWxkKHQpfSksIG8ucmV2ZXJzZSgpLmZvckVhY2goZnVuY3Rpb24gKGUpIHt2YXIgdCA9IGUuY2xvbmVOb2RlKCEwKTsgQi5pbnNlcnRCZWZvcmUodCwgQi5maXJzdENoaWxkKX0pLCBCLmFkZEV2ZW50TGlzdGVuZXIoTy50cmFuc2l0aW9uRW5kLCB5KSwgZi5jYWxsKEIuY2hpbGRyZW4pfSBmdW5jdGlvbiBvKHQsIG4sIGkpIHsoMCwgbFtcImRlZmF1bHRcIl0pKGUsIHQgKyBcIi5sb3J5LlwiICsgbiwgaSl9IGZ1bmN0aW9uIGEoZSwgdCwgbikge3ZhciBpID0gQiAmJiBCLnN0eWxlOyBpICYmIChpW08udHJhbnNpdGlvbiArIFwiVGltaW5nRnVuY3Rpb25cIl0gPSBuLCBpW08udHJhbnNpdGlvbiArIFwiRHVyYXRpb25cIl0gPSB0ICsgXCJtc1wiLCBPLmhhc1RyYW5zbGF0ZTNkID8gaVtPLnRyYW5zZm9ybV0gPSBcInRyYW5zbGF0ZTNkKFwiICsgZSArIFwicHgsIDAsIDApXCIgOiBpW08udHJhbnNmb3JtXSA9IFwidHJhbnNsYXRlKFwiICsgZSArIFwicHgsIDApXCIpfSBmdW5jdGlvbiBkKGUsIHQpIHt2YXIgaSA9IHosIHIgPSBpLnNsaWRlU3BlZWQsIHMgPSBpLnNsaWRlc1RvU2Nyb2xsLCBkID0gaS5pbmZpbml0ZSwgbCA9IGkucmV3aW5kLCBjID0gaS5yZXdpbmRTcGVlZCwgdSA9IGkuZWFzZSwgdiA9IGkuY2xhc3NOYW1lQWN0aXZlU2xpZGUsIG0gPSByLCBwID0gdCA/IFAgKyAxIDogUCAtIDEsIGggPSBNYXRoLnJvdW5kKE0gLSBTKTsgbyhcImJlZm9yZVwiLCBcInNsaWRlXCIsIHtpbmRleDogUCwgbmV4dFNsaWRlOiBwfSksIFwibnVtYmVyXCIgIT0gdHlwZW9mIGUgJiYgKGUgPSB0ID8gUCArIHMgOiBQIC0gcyksIGUgPSBNYXRoLm1pbihNYXRoLm1heChlLCAwKSwgXy5sZW5ndGggLSAxKSwgZCAmJiB2b2lkIDAgPT09IHQgJiYgKGUgKz0gZCk7IHZhciBFID0gTWF0aC5taW4oTWF0aC5tYXgoX1tlXS5vZmZzZXRMZWZ0ICogLTEsIGggKiAtMSksIDApOyBsICYmIE1hdGguYWJzKE4ueCkgPT09IGggJiYgdCAmJiAoRSA9IDAsIGUgPSAwLCBtID0gYyksIGEoRSwgbSwgdSksIE4ueCA9IEUsIF9bZV0ub2Zmc2V0TGVmdCA8PSBoICYmIChQID0gZSksICFkIHx8IGUgIT09IF8ubGVuZ3RoIC0gZCAmJiAwICE9PSBlIHx8ICh0ICYmIChQID0gZCksIHQgfHwgKFAgPSBfLmxlbmd0aCAtIDIgKiBkKSwgTi54ID0gX1tQXS5vZmZzZXRMZWZ0ICogLTEsIEEgPSBmdW5jdGlvbiAoKSB7YShfW1BdLm9mZnNldExlZnQgKiAtMSwgMCwgdm9pZCAwKX0pLCB2ICYmIG4oZi5jYWxsKF8pLCBQKSwgbyhcImFmdGVyXCIsIFwic2xpZGVcIiwge2N1cnJlbnRTbGlkZTogUH0pfSBmdW5jdGlvbiBjKCkge28oXCJiZWZvcmVcIiwgXCJpbml0XCIpLCBPID0gKDAsIHNbXCJkZWZhdWx0XCJdKSgpLCB6ID0gcih7fSwgdVtcImRlZmF1bHRcIl0sIHQpOyB2YXIgYSA9IHosIGQgPSBhLmNsYXNzTmFtZUZyYW1lLCBsID0gYS5jbGFzc05hbWVTbGlkZUNvbnRhaW5lciwgYyA9IGEuY2xhc3NOYW1lUHJldkN0cmwsIG0gPSBhLmNsYXNzTmFtZU5leHRDdHJsLCBwID0gYS5lbmFibGVNb3VzZUV2ZW50cywgYiA9IGEuY2xhc3NOYW1lQWN0aXZlU2xpZGU7IGogPSBlLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoZClbMF0sIEIgPSBqLmdldEVsZW1lbnRzQnlDbGFzc05hbWUobClbMF0sIGsgPSBlLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoYylbMF0sIFQgPSBlLmdldEVsZW1lbnRzQnlDbGFzc05hbWUobSlbMF0sIE4gPSB7eDogQi5vZmZzZXRMZWZ0LCB5OiBCLm9mZnNldFRvcH0sIF8gPSB6LmluZmluaXRlID8gaShmLmNhbGwoQi5jaGlsZHJlbikpIDogZi5jYWxsKEIuY2hpbGRyZW4pLCB2KCksIGIgJiYgbihfLCBQKSwgayAmJiBUICYmIChrLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoKSwgVC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgRSkpLCBqLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHgpLCBwICYmIChqLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgeCksIGouYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGcpKSwgei53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBDKSwgbyhcImFmdGVyXCIsIFwiaW5pdFwiKX0gZnVuY3Rpb24gdigpIHt2YXIgZSA9IHosIHQgPSBlLmluZmluaXRlLCBpID0gZS5lYXNlLCBvID0gZS5yZXdpbmRTcGVlZCwgciA9IGUucmV3aW5kT25SZXNpemUsIHMgPSBlLmNsYXNzTmFtZUFjdGl2ZVNsaWRlOyBNID0gQi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB8fCBCLm9mZnNldFdpZHRoLCBTID0gai5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB8fCBqLm9mZnNldFdpZHRoLCBTID09PSBNICYmIChNID0gXy5yZWR1Y2UoZnVuY3Rpb24gKGUsIHQpIHtyZXR1cm4gZSArIHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggfHwgdC5vZmZzZXRXaWR0aH0sIDApKSwgciA/IFAgPSAwIDogKGkgPSBudWxsLCBvID0gMCksIHQgPyAoYShfW1AgKyB0XS5vZmZzZXRMZWZ0ICogLTEsIDAsIG51bGwpLCBQICs9IHQsIE4ueCA9IF9bUF0ub2Zmc2V0TGVmdCAqIC0xKSA6IChhKF9bUF0ub2Zmc2V0TGVmdCAqIC0xLCBvLCBpKSwgTi54ID0gX1tQXS5vZmZzZXRMZWZ0ICogLTEpLCBzICYmIG4oZi5jYWxsKF8pLCBQKX0gZnVuY3Rpb24gbShlKSB7ZChlKX0gZnVuY3Rpb24gcCgpIHtyZXR1cm4gUCAtIHouaW5maW5pdGUgfHwgMH0gZnVuY3Rpb24gaCgpIHtkKCExLCAhMSl9IGZ1bmN0aW9uIEUoKSB7ZCghMSwgITApfSBmdW5jdGlvbiBiKCkge28oXCJiZWZvcmVcIiwgXCJkZXN0cm95XCIpLCBqLnJlbW92ZUV2ZW50TGlzdGVuZXIoTy50cmFuc2l0aW9uRW5kLCB5KSwgai5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB4KSwgai5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIEwpLCBqLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB3KSwgai5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIEwpLCBqLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgeCksIGoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdyksIGoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgdyksIGoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGcpLCB6LndpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIEMpLCBrICYmIGsucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGgpLCBUICYmIFQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIEUpLCB6LmluZmluaXRlICYmIEFycmF5LmFwcGx5KG51bGwsIEFycmF5KHouaW5maW5pdGUpKS5mb3JFYWNoKGZ1bmN0aW9uICgpIHtCLnJlbW92ZUNoaWxkKEIuZmlyc3RDaGlsZCksIEIucmVtb3ZlQ2hpbGQoQi5sYXN0Q2hpbGQpfSksIG8oXCJhZnRlclwiLCBcImRlc3Ryb3lcIil9IGZ1bmN0aW9uIHkoKSB7QSAmJiAoQSgpLCBBID0gdm9pZCAwKX0gZnVuY3Rpb24geChlKSB7dmFyIHQgPSB6LCBuID0gdC5lbmFibGVNb3VzZUV2ZW50cywgaSA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXSA6IGU7IG4gJiYgKGouYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBMKSwgai5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB3KSwgai5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB3KSksIGouYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBMKSwgai5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdyk7IHZhciByID0gaS5wYWdlWCwgYSA9IGkucGFnZVk7IEQgPSB7eDogciwgeTogYSwgdGltZTogRGF0ZS5ub3coKX0sIEYgPSB2b2lkIDAsIFIgPSB7fSwgbyhcIm9uXCIsIFwidG91Y2hzdGFydFwiLCB7ZXZlbnQ6IGV9KX0gZnVuY3Rpb24gTChlKSB7dmFyIHQgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlLCBuID0gdC5wYWdlWCwgaSA9IHQucGFnZVk7IFIgPSB7eDogbiAtIEQueCwgeTogaSAtIEQueX0sIFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIEYgJiYgKEYgPSAhIShGIHx8IE1hdGguYWJzKFIueCkgPCBNYXRoLmFicyhSLnkpKSksICFGICYmIEQgJiYgKGUucHJldmVudERlZmF1bHQoKSwgYShOLnggKyBSLngsIDAsIG51bGwpKSwgbyhcIm9uXCIsIFwidG91Y2htb3ZlXCIsIHtldmVudDogZX0pfSBmdW5jdGlvbiB3KGUpIHt2YXIgdCA9IEQgPyBEYXRlLm5vdygpIC0gRC50aW1lIDogdm9pZCAwLCBuID0gTnVtYmVyKHQpIDwgMzAwICYmIE1hdGguYWJzKFIueCkgPiAyNSB8fCBNYXRoLmFicyhSLngpID4gUyAvIDMsIGkgPSAhUCAmJiBSLnggPiAwIHx8IFAgPT09IF8ubGVuZ3RoIC0gMSAmJiBSLnggPCAwLCByID0gUi54IDwgMDsgRiB8fCAobiAmJiAhaSA/IGQoITEsIHIpIDogYShOLngsIHouc25hcEJhY2tTcGVlZCkpLCBEID0gdm9pZCAwLCBqLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgTCksIGoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHcpLCBqLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgTCksIGoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdyksIGoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgdyksIG8oXCJvblwiLCBcInRvdWNoZW5kXCIsIHtldmVudDogZX0pfSBmdW5jdGlvbiBnKGUpIHtSLnggJiYgZS5wcmV2ZW50RGVmYXVsdCgpfSBmdW5jdGlvbiBDKGUpIHt2KCksIG8oXCJvblwiLCBcInJlc2l6ZVwiLCB7ZXZlbnQ6IGV9KX0gdmFyIE4gPSB2b2lkIDAsIE0gPSB2b2lkIDAsIFMgPSB2b2lkIDAsIF8gPSB2b2lkIDAsIGogPSB2b2lkIDAsIEIgPSB2b2lkIDAsIGsgPSB2b2lkIDAsIFQgPSB2b2lkIDAsIE8gPSB2b2lkIDAsIEEgPSB2b2lkIDAsIFAgPSAwLCB6ID0ge307IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGpRdWVyeSAmJiBlIGluc3RhbmNlb2YgalF1ZXJ5ICYmIChlID0gZVswXSk7IHZhciBEID0gdm9pZCAwLCBSID0gdm9pZCAwLCBGID0gdm9pZCAwOyByZXR1cm4gYygpLCB7c2V0dXA6IGMsIHJlc2V0OiB2LCBzbGlkZVRvOiBtLCByZXR1cm5JbmRleDogcCwgcHJldjogaCwgbmV4dDogRSwgZGVzdHJveTogYn19IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiAhMH0pOyB2YXIgciA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKGUpIHtmb3IgKHZhciB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykge3ZhciBuID0gYXJndW1lbnRzW3RdOyBmb3IgKHZhciBpIGluIG4pIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLCBpKSAmJiAoZVtpXSA9IG5baV0pfSByZXR1cm4gZX07IHQubG9yeSA9IG87IHZhciBhID0gbigyKSwgcyA9IGkoYSksIGQgPSBuKDMpLCBsID0gaShkKSwgYyA9IG4oNSksIHUgPSBpKGMpLCBmID0gQXJyYXkucHJvdG90eXBlLnNsaWNlfSwgZnVuY3Rpb24gKGUsIHQpIHsoZnVuY3Rpb24gKGUpIHtcInVzZSBzdHJpY3RcIjsgZnVuY3Rpb24gbigpIHt2YXIgdCA9IHZvaWQgMCwgbiA9IHZvaWQgMCwgaSA9IHZvaWQgMCwgbyA9IHZvaWQgMDsgcmV0dXJuIGZ1bmN0aW9uICgpIHt2YXIgciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJfXCIpLCBhID0gci5zdHlsZSwgcyA9IHZvaWQgMDsgXCJcIiA9PT0gYVtzID0gXCJ3ZWJraXRUcmFuc2l0aW9uXCJdICYmIChpID0gXCJ3ZWJraXRUcmFuc2l0aW9uRW5kXCIsIG4gPSBzKSwgXCJcIiA9PT0gYVtzID0gXCJ0cmFuc2l0aW9uXCJdICYmIChpID0gXCJ0cmFuc2l0aW9uZW5kXCIsIG4gPSBzKSwgXCJcIiA9PT0gYVtzID0gXCJ3ZWJraXRUcmFuc2Zvcm1cIl0gJiYgKHQgPSBzKSwgXCJcIiA9PT0gYVtzID0gXCJtc1RyYW5zZm9ybVwiXSAmJiAodCA9IHMpLCBcIlwiID09PSBhW3MgPSBcInRyYW5zZm9ybVwiXSAmJiAodCA9IHMpLCBkb2N1bWVudC5ib2R5Lmluc2VydEJlZm9yZShyLCBudWxsKSwgYVt0XSA9IFwidHJhbnNsYXRlM2QoMCwgMCwgMClcIiwgbyA9ICEhZS5nZXRDb21wdXRlZFN0eWxlKHIpLmdldFByb3BlcnR5VmFsdWUodCksIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQocil9KCksIHt0cmFuc2Zvcm06IHQsIHRyYW5zaXRpb246IG4sIHRyYW5zaXRpb25FbmQ6IGksIGhhc1RyYW5zbGF0ZTNkOiBvfX0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6ICEwfSksIHRbXCJkZWZhdWx0XCJdID0gbn0pLmNhbGwodCwgZnVuY3Rpb24gKCkge3JldHVybiB0aGlzfSgpKX0sIGZ1bmN0aW9uIChlLCB0LCBuKSB7XCJ1c2Ugc3RyaWN0XCI7IGZ1bmN0aW9uIGkoZSkge3JldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7XCJkZWZhdWx0XCI6IGV9fSBmdW5jdGlvbiBvKGUsIHQsIG4pIHt2YXIgaSA9IG5ldyBhW1wiZGVmYXVsdFwiXSh0LCB7YnViYmxlczogITAsIGNhbmNlbGFibGU6ICEwLCBkZXRhaWw6IG59KTsgZS5kaXNwYXRjaEV2ZW50KGkpfSBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogITB9KSwgdFtcImRlZmF1bHRcIl0gPSBvOyB2YXIgciA9IG4oNCksIGEgPSBpKHIpfSwgZnVuY3Rpb24gKGUsIHQpIHsoZnVuY3Rpb24gKHQpIHtmdW5jdGlvbiBuKCkge3RyeSB7dmFyIGUgPSBuZXcgaShcImNhdFwiLCB7ZGV0YWlsOiB7Zm9vOiBcImJhclwifX0pOyByZXR1cm4gXCJjYXRcIiA9PT0gZS50eXBlICYmIFwiYmFyXCIgPT09IGUuZGV0YWlsLmZvb30gY2F0Y2ggKHQpIHt9IHJldHVybiAhMX0gdmFyIGkgPSB0LkN1c3RvbUV2ZW50OyBlLmV4cG9ydHMgPSBuKCkgPyBpIDogXCJmdW5jdGlvblwiID09IHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFdmVudCA/IGZ1bmN0aW9uIChlLCB0KSB7dmFyIG4gPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpOyByZXR1cm4gdCA/IG4uaW5pdEN1c3RvbUV2ZW50KGUsIHQuYnViYmxlcywgdC5jYW5jZWxhYmxlLCB0LmRldGFpbCkgOiBuLmluaXRDdXN0b21FdmVudChlLCAhMSwgITEsIHZvaWQgMCksIG59IDogZnVuY3Rpb24gKGUsIHQpIHt2YXIgbiA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KCk7IHJldHVybiBuLnR5cGUgPSBlLCB0ID8gKG4uYnViYmxlcyA9IEJvb2xlYW4odC5idWJibGVzKSwgbi5jYW5jZWxhYmxlID0gQm9vbGVhbih0LmNhbmNlbGFibGUpLCBuLmRldGFpbCA9IHQuZGV0YWlsKSA6IChuLmJ1YmJsZXMgPSAhMSwgbi5jYW5jZWxhYmxlID0gITEsIG4uZGV0YWlsID0gdm9pZCAwKSwgbn19KS5jYWxsKHQsIGZ1bmN0aW9uICgpIHtyZXR1cm4gdGhpc30oKSl9LCBmdW5jdGlvbiAoZSwgdCkge1widXNlIHN0cmljdFwiOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogITB9KSwgdFtcImRlZmF1bHRcIl0gPSB7c2xpZGVzVG9TY3JvbGw6IDEsIHNsaWRlU3BlZWQ6IDMwMCwgcmV3aW5kU3BlZWQ6IDYwMCwgc25hcEJhY2tTcGVlZDogMjAwLCBlYXNlOiBcImVhc2VcIiwgcmV3aW5kOiAhMSwgaW5maW5pdGU6ICExLCBjbGFzc05hbWVGcmFtZTogXCJqc19mcmFtZVwiLCBjbGFzc05hbWVTbGlkZUNvbnRhaW5lcjogXCJqc19zbGlkZXNcIiwgY2xhc3NOYW1lUHJldkN0cmw6IFwianNfcHJldlwiLCBjbGFzc05hbWVOZXh0Q3RybDogXCJqc19uZXh0XCIsIGNsYXNzTmFtZUFjdGl2ZVNsaWRlOiBcImFjdGl2ZVwiLCBlbmFibGVNb3VzZUV2ZW50czogITEsIHdpbmRvdzogd2luZG93LCByZXdpbmRPblJlc2l6ZTogITB9fV0pfSk7XG5cbihmdW5jdGlvbiAoKSB7XG5cbiAgICBmdW5jdGlvbiBDYXJvdXNlbChlbCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBsb3J5KGVsLCB7XG4gICAgICAgICAgICBpbmZpbml0ZTogMSxcbiAgICAgICAgICAgIGVuYWJsZU1vdXNlRXZlbnRzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFNodWZmbGUgQ2Fyb3VzZWxcbiAgICBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWNhcm91c2VsXScpKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgdWwgPSBlbC5xdWVyeVNlbGVjdG9yKCd1bCcpO1xuICAgICAgICBmb3IgKHZhciBpID0gdWwuY2hpbGRyZW4ubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdWwuYXBwZW5kQ2hpbGQodWwuY2hpbGRyZW5bTWF0aC5yYW5kb20oKSAqIGkgfCAwXSk7XG4gICAgICAgIH1cbiAgICAgICAgQ2Fyb3VzZWwoZWwpO1xuICAgIH0pO1xufSkoKTtcbiIsIi8qKlxuICogc3RpY2t5LXNpZGViYXIgLSBBIEphdmFTY3JpcHQgcGx1Z2luIGZvciBtYWtpbmcgc21hcnQgYW5kIGhpZ2ggcGVyZm9ybWFuY2UuXG4gKiBAdmVyc2lvbiB2My4zLjFcbiAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9hYm91b2xpYS9zdGlja3ktc2lkZWJhclxuICogQGF1dGhvciBBaG1lZCBCb3VodW9saWFcbiAqIEBsaWNlbnNlIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuKiovXG4hZnVuY3Rpb24gKHQsIGUpIHtcIm9iamVjdFwiID09IHR5cGVvZiBleHBvcnRzICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIG1vZHVsZSA/IGUoZXhwb3J0cykgOiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFtcImV4cG9ydHNcIl0sIGUpIDogZSh0LlN0aWNreVNpZGViYXIgPSB7fSl9KHRoaXMsIGZ1bmN0aW9uICh0KSB7XCJ1c2Ugc3RyaWN0XCI7IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHdpbmRvdyA/IHdpbmRvdyA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGdsb2JhbCA/IGdsb2JhbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHNlbGYgJiYgc2VsZjsgdmFyIGUsIGksIG4gPSAoZnVuY3Rpb24gKHQsIGUpIHsoZnVuY3Rpb24gKHQpIHtPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogITB9KTsgdmFyIGwsIG4sIGUgPSBmdW5jdGlvbiAoKSB7ZnVuY3Rpb24gbih0LCBlKSB7Zm9yICh2YXIgaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSsrKSB7dmFyIG4gPSBlW2ldOyBuLmVudW1lcmFibGUgPSBuLmVudW1lcmFibGUgfHwgITEsIG4uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBuICYmIChuLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgbi5rZXksIG4pfSB9IHJldHVybiBmdW5jdGlvbiAodCwgZSwgaSkge3JldHVybiBlICYmIG4odC5wcm90b3R5cGUsIGUpLCBpICYmIG4odCwgaSksIHR9fSgpLCBpID0gKGwgPSBcIi5zdGlja3lTaWRlYmFyXCIsIG4gPSB7dG9wU3BhY2luZzogMCwgYm90dG9tU3BhY2luZzogMCwgY29udGFpbmVyU2VsZWN0b3I6ICExLCBpbm5lcldyYXBwZXJTZWxlY3RvcjogXCIuaW5uZXItd3JhcHBlci1zdGlja3lcIiwgc3RpY2t5Q2xhc3M6IFwiaXMtYWZmaXhlZFwiLCByZXNpemVTZW5zb3I6ICEwLCBtaW5XaWR0aDogITF9LCBmdW5jdGlvbiAoKSB7ZnVuY3Rpb24gYyh0KSB7dmFyIGUgPSB0aGlzLCBpID0gMSA8IGFyZ3VtZW50cy5sZW5ndGggJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMV0gPyBhcmd1bWVudHNbMV0gOiB7fTsgaWYgKGZ1bmN0aW9uICh0LCBlKSB7aWYgKCEodCBpbnN0YW5jZW9mIGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLCBjKSwgdGhpcy5vcHRpb25zID0gYy5leHRlbmQobiwgaSksIHRoaXMuc2lkZWJhciA9IFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHQpIDogdCwgdm9pZCAwID09PSB0aGlzLnNpZGViYXIpIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIG5vIHNwZWNpZmljIHNpZGViYXIgZWxlbWVudC5cIik7IHRoaXMuc2lkZWJhcklubmVyID0gITEsIHRoaXMuY29udGFpbmVyID0gdGhpcy5zaWRlYmFyLnBhcmVudEVsZW1lbnQsIHRoaXMuYWZmaXhlZFR5cGUgPSBcIlNUQVRJQ1wiLCB0aGlzLmRpcmVjdGlvbiA9IFwiZG93blwiLCB0aGlzLnN1cHBvcnQgPSB7dHJhbnNmb3JtOiAhMSwgdHJhbnNmb3JtM2Q6ICExfSwgdGhpcy5faW5pdGlhbGl6ZWQgPSAhMSwgdGhpcy5fcmVTdHlsZSA9ICExLCB0aGlzLl9icmVha3BvaW50ID0gITEsIHRoaXMuZGltZW5zaW9ucyA9IHt0cmFuc2xhdGVZOiAwLCBtYXhUcmFuc2xhdGVZOiAwLCB0b3BTcGFjaW5nOiAwLCBsYXN0VG9wU3BhY2luZzogMCwgYm90dG9tU3BhY2luZzogMCwgbGFzdEJvdHRvbVNwYWNpbmc6IDAsIHNpZGViYXJIZWlnaHQ6IDAsIHNpZGViYXJXaWR0aDogMCwgY29udGFpbmVyVG9wOiAwLCBjb250YWluZXJIZWlnaHQ6IDAsIHZpZXdwb3J0SGVpZ2h0OiAwLCB2aWV3cG9ydFRvcDogMCwgbGFzdFZpZXdwb3J0VG9wOiAwfSwgW1wiaGFuZGxlRXZlbnRcIl0uZm9yRWFjaChmdW5jdGlvbiAodCkge2VbdF0gPSBlW3RdLmJpbmQoZSl9KSwgdGhpcy5pbml0aWFsaXplKCl9IHJldHVybiBlKGMsIFt7a2V5OiBcImluaXRpYWxpemVcIiwgdmFsdWU6IGZ1bmN0aW9uICgpIHt2YXIgaSA9IHRoaXM7IGlmICh0aGlzLl9zZXRTdXBwb3J0RmVhdHVyZXMoKSwgdGhpcy5vcHRpb25zLmlubmVyV3JhcHBlclNlbGVjdG9yICYmICh0aGlzLnNpZGViYXJJbm5lciA9IHRoaXMuc2lkZWJhci5xdWVyeVNlbGVjdG9yKHRoaXMub3B0aW9ucy5pbm5lcldyYXBwZXJTZWxlY3RvciksIG51bGwgPT09IHRoaXMuc2lkZWJhcklubmVyICYmICh0aGlzLnNpZGViYXJJbm5lciA9ICExKSksICF0aGlzLnNpZGViYXJJbm5lcikge3ZhciB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTsgZm9yICh0LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiaW5uZXItd3JhcHBlci1zdGlja3lcIiksIHRoaXMuc2lkZWJhci5hcHBlbmRDaGlsZCh0KTsgdGhpcy5zaWRlYmFyLmZpcnN0Q2hpbGQgIT0gdDspdC5hcHBlbmRDaGlsZCh0aGlzLnNpZGViYXIuZmlyc3RDaGlsZCk7IHRoaXMuc2lkZWJhcklubmVyID0gdGhpcy5zaWRlYmFyLnF1ZXJ5U2VsZWN0b3IoXCIuaW5uZXItd3JhcHBlci1zdGlja3lcIil9IGlmICh0aGlzLm9wdGlvbnMuY29udGFpbmVyU2VsZWN0b3IpIHt2YXIgZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5vcHRpb25zLmNvbnRhaW5lclNlbGVjdG9yKTsgaWYgKChlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZSkpLmZvckVhY2goZnVuY3Rpb24gKHQsIGUpIHt0LmNvbnRhaW5zKGkuc2lkZWJhcikgJiYgKGkuY29udGFpbmVyID0gdCl9KSwgIWUubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY29udGFpbmVyIGRvZXMgbm90IGNvbnRhaW5zIG9uIHRoZSBzaWRlYmFyLlwiKX0gXCJmdW5jdGlvblwiICE9IHR5cGVvZiB0aGlzLm9wdGlvbnMudG9wU3BhY2luZyAmJiAodGhpcy5vcHRpb25zLnRvcFNwYWNpbmcgPSBwYXJzZUludCh0aGlzLm9wdGlvbnMudG9wU3BhY2luZykgfHwgMCksIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdGhpcy5vcHRpb25zLmJvdHRvbVNwYWNpbmcgJiYgKHRoaXMub3B0aW9ucy5ib3R0b21TcGFjaW5nID0gcGFyc2VJbnQodGhpcy5vcHRpb25zLmJvdHRvbVNwYWNpbmcpIHx8IDApLCB0aGlzLl93aWR0aEJyZWFrcG9pbnQoKSwgdGhpcy5jYWxjRGltZW5zaW9ucygpLCB0aGlzLnN0aWNreVBvc2l0aW9uKCksIHRoaXMuYmluZEV2ZW50cygpLCB0aGlzLl9pbml0aWFsaXplZCA9ICEwfX0sIHtrZXk6IFwiYmluZEV2ZW50c1wiLCB2YWx1ZTogZnVuY3Rpb24gKCkge3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMsIHtwYXNzaXZlOiAhMCwgY2FwdHVyZTogITF9KSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcywge3Bhc3NpdmU6ICEwLCBjYXB0dXJlOiAhMX0pLCB0aGlzLnNpZGViYXIuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZVwiICsgbCwgdGhpcyksIHRoaXMub3B0aW9ucy5yZXNpemVTZW5zb3IgJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgUmVzaXplU2Vuc29yICYmIChuZXcgUmVzaXplU2Vuc29yKHRoaXMuc2lkZWJhcklubmVyLCB0aGlzLmhhbmRsZUV2ZW50KSwgbmV3IFJlc2l6ZVNlbnNvcih0aGlzLmNvbnRhaW5lciwgdGhpcy5oYW5kbGVFdmVudCkpfX0sIHtrZXk6IFwiaGFuZGxlRXZlbnRcIiwgdmFsdWU6IGZ1bmN0aW9uICh0KSB7dGhpcy51cGRhdGVTdGlja3kodCl9fSwge2tleTogXCJjYWxjRGltZW5zaW9uc1wiLCB2YWx1ZTogZnVuY3Rpb24gKCkge2lmICghdGhpcy5fYnJlYWtwb2ludCkge3ZhciB0ID0gdGhpcy5kaW1lbnNpb25zOyB0LmNvbnRhaW5lclRvcCA9IGMub2Zmc2V0UmVsYXRpdmUodGhpcy5jb250YWluZXIpLnRvcCwgdC5jb250YWluZXJIZWlnaHQgPSB0aGlzLmNvbnRhaW5lci5jbGllbnRIZWlnaHQsIHQuY29udGFpbmVyQm90dG9tID0gdC5jb250YWluZXJUb3AgKyB0LmNvbnRhaW5lckhlaWdodCwgdC5zaWRlYmFySGVpZ2h0ID0gdGhpcy5zaWRlYmFySW5uZXIub2Zmc2V0SGVpZ2h0LCB0LnNpZGViYXJXaWR0aCA9IHRoaXMuc2lkZWJhcklubmVyLm9mZnNldFdpZHRoLCB0LnZpZXdwb3J0SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0LCB0Lm1heFRyYW5zbGF0ZVkgPSB0LmNvbnRhaW5lckhlaWdodCAtIHQuc2lkZWJhckhlaWdodCwgdGhpcy5fY2FsY0RpbWVuc2lvbnNXaXRoU2Nyb2xsKCl9IH19LCB7a2V5OiBcIl9jYWxjRGltZW5zaW9uc1dpdGhTY3JvbGxcIiwgdmFsdWU6IGZ1bmN0aW9uICgpIHt2YXIgdCA9IHRoaXMuZGltZW5zaW9uczsgdC5zaWRlYmFyTGVmdCA9IGMub2Zmc2V0UmVsYXRpdmUodGhpcy5zaWRlYmFyKS5sZWZ0LCB0LnZpZXdwb3J0VG9wID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCwgdC52aWV3cG9ydEJvdHRvbSA9IHQudmlld3BvcnRUb3AgKyB0LnZpZXdwb3J0SGVpZ2h0LCB0LnZpZXdwb3J0TGVmdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCwgdC50b3BTcGFjaW5nID0gdGhpcy5vcHRpb25zLnRvcFNwYWNpbmcsIHQuYm90dG9tU3BhY2luZyA9IHRoaXMub3B0aW9ucy5ib3R0b21TcGFjaW5nLCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHQudG9wU3BhY2luZyAmJiAodC50b3BTcGFjaW5nID0gcGFyc2VJbnQodC50b3BTcGFjaW5nKHRoaXMuc2lkZWJhcikpIHx8IDApLCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHQuYm90dG9tU3BhY2luZyAmJiAodC5ib3R0b21TcGFjaW5nID0gcGFyc2VJbnQodC5ib3R0b21TcGFjaW5nKHRoaXMuc2lkZWJhcikpIHx8IDApLCBcIlZJRVdQT1JULVRPUFwiID09PSB0aGlzLmFmZml4ZWRUeXBlID8gdC50b3BTcGFjaW5nIDwgdC5sYXN0VG9wU3BhY2luZyAmJiAodC50cmFuc2xhdGVZICs9IHQubGFzdFRvcFNwYWNpbmcgLSB0LnRvcFNwYWNpbmcsIHRoaXMuX3JlU3R5bGUgPSAhMCkgOiBcIlZJRVdQT1JULUJPVFRPTVwiID09PSB0aGlzLmFmZml4ZWRUeXBlICYmIHQuYm90dG9tU3BhY2luZyA8IHQubGFzdEJvdHRvbVNwYWNpbmcgJiYgKHQudHJhbnNsYXRlWSArPSB0Lmxhc3RCb3R0b21TcGFjaW5nIC0gdC5ib3R0b21TcGFjaW5nLCB0aGlzLl9yZVN0eWxlID0gITApLCB0Lmxhc3RUb3BTcGFjaW5nID0gdC50b3BTcGFjaW5nLCB0Lmxhc3RCb3R0b21TcGFjaW5nID0gdC5ib3R0b21TcGFjaW5nfX0sIHtrZXk6IFwiaXNTaWRlYmFyRml0c1ZpZXdwb3J0XCIsIHZhbHVlOiBmdW5jdGlvbiAoKSB7dmFyIHQgPSB0aGlzLmRpbWVuc2lvbnMsIGUgPSBcImRvd25cIiA9PT0gdGhpcy5zY3JvbGxEaXJlY3Rpb24gPyB0Lmxhc3RCb3R0b21TcGFjaW5nIDogdC5sYXN0VG9wU3BhY2luZzsgcmV0dXJuIHRoaXMuZGltZW5zaW9ucy5zaWRlYmFySGVpZ2h0ICsgZSA8IHRoaXMuZGltZW5zaW9ucy52aWV3cG9ydEhlaWdodH19LCB7a2V5OiBcIm9ic2VydmVTY3JvbGxEaXJcIiwgdmFsdWU6IGZ1bmN0aW9uICgpIHt2YXIgdCA9IHRoaXMuZGltZW5zaW9uczsgaWYgKHQubGFzdFZpZXdwb3J0VG9wICE9PSB0LnZpZXdwb3J0VG9wKSB7dmFyIGUgPSBcImRvd25cIiA9PT0gdGhpcy5kaXJlY3Rpb24gPyBNYXRoLm1pbiA6IE1hdGgubWF4OyB0LnZpZXdwb3J0VG9wID09PSBlKHQudmlld3BvcnRUb3AsIHQubGFzdFZpZXdwb3J0VG9wKSAmJiAodGhpcy5kaXJlY3Rpb24gPSBcImRvd25cIiA9PT0gdGhpcy5kaXJlY3Rpb24gPyBcInVwXCIgOiBcImRvd25cIil9IH19LCB7a2V5OiBcImdldEFmZml4VHlwZVwiLCB2YWx1ZTogZnVuY3Rpb24gKCkge3RoaXMuX2NhbGNEaW1lbnNpb25zV2l0aFNjcm9sbCgpOyB2YXIgdCA9IHRoaXMuZGltZW5zaW9ucywgZSA9IHQudmlld3BvcnRUb3AgKyB0LnRvcFNwYWNpbmcsIGkgPSB0aGlzLmFmZml4ZWRUeXBlOyByZXR1cm4gZSA8PSB0LmNvbnRhaW5lclRvcCB8fCB0LmNvbnRhaW5lckhlaWdodCA8PSB0LnNpZGViYXJIZWlnaHQgPyAodC50cmFuc2xhdGVZID0gMCwgaSA9IFwiU1RBVElDXCIpIDogaSA9IFwidXBcIiA9PT0gdGhpcy5kaXJlY3Rpb24gPyB0aGlzLl9nZXRBZmZpeFR5cGVTY3JvbGxpbmdVcCgpIDogdGhpcy5fZ2V0QWZmaXhUeXBlU2Nyb2xsaW5nRG93bigpLCB0LnRyYW5zbGF0ZVkgPSBNYXRoLm1heCgwLCB0LnRyYW5zbGF0ZVkpLCB0LnRyYW5zbGF0ZVkgPSBNYXRoLm1pbih0LmNvbnRhaW5lckhlaWdodCwgdC50cmFuc2xhdGVZKSwgdC50cmFuc2xhdGVZID0gTWF0aC5yb3VuZCh0LnRyYW5zbGF0ZVkpLCB0Lmxhc3RWaWV3cG9ydFRvcCA9IHQudmlld3BvcnRUb3AsIGl9fSwge2tleTogXCJfZ2V0QWZmaXhUeXBlU2Nyb2xsaW5nRG93blwiLCB2YWx1ZTogZnVuY3Rpb24gKCkge3ZhciB0ID0gdGhpcy5kaW1lbnNpb25zLCBlID0gdC5zaWRlYmFySGVpZ2h0ICsgdC5jb250YWluZXJUb3AsIGkgPSB0LnZpZXdwb3J0VG9wICsgdC50b3BTcGFjaW5nLCBuID0gdC52aWV3cG9ydEJvdHRvbSAtIHQuYm90dG9tU3BhY2luZywgbyA9IHRoaXMuYWZmaXhlZFR5cGU7IHJldHVybiB0aGlzLmlzU2lkZWJhckZpdHNWaWV3cG9ydCgpID8gdC5zaWRlYmFySGVpZ2h0ICsgaSA+PSB0LmNvbnRhaW5lckJvdHRvbSA/ICh0LnRyYW5zbGF0ZVkgPSB0LmNvbnRhaW5lckJvdHRvbSAtIGUsIG8gPSBcIkNPTlRBSU5FUi1CT1RUT01cIikgOiBpID49IHQuY29udGFpbmVyVG9wICYmICh0LnRyYW5zbGF0ZVkgPSBpIC0gdC5jb250YWluZXJUb3AsIG8gPSBcIlZJRVdQT1JULVRPUFwiKSA6IHQuY29udGFpbmVyQm90dG9tIDw9IG4gPyAodC50cmFuc2xhdGVZID0gdC5jb250YWluZXJCb3R0b20gLSBlLCBvID0gXCJDT05UQUlORVItQk9UVE9NXCIpIDogZSArIHQudHJhbnNsYXRlWSA8PSBuID8gKHQudHJhbnNsYXRlWSA9IG4gLSBlLCBvID0gXCJWSUVXUE9SVC1CT1RUT01cIikgOiB0LmNvbnRhaW5lclRvcCArIHQudHJhbnNsYXRlWSA8PSBpICYmIDAgIT09IHQudHJhbnNsYXRlWSAmJiB0Lm1heFRyYW5zbGF0ZVkgIT09IHQudHJhbnNsYXRlWSAmJiAobyA9IFwiVklFV1BPUlQtVU5CT1RUT01cIiksIG99fSwge2tleTogXCJfZ2V0QWZmaXhUeXBlU2Nyb2xsaW5nVXBcIiwgdmFsdWU6IGZ1bmN0aW9uICgpIHt2YXIgdCA9IHRoaXMuZGltZW5zaW9ucywgZSA9IHQuc2lkZWJhckhlaWdodCArIHQuY29udGFpbmVyVG9wLCBpID0gdC52aWV3cG9ydFRvcCArIHQudG9wU3BhY2luZywgbiA9IHQudmlld3BvcnRCb3R0b20gLSB0LmJvdHRvbVNwYWNpbmcsIG8gPSB0aGlzLmFmZml4ZWRUeXBlOyByZXR1cm4gaSA8PSB0LnRyYW5zbGF0ZVkgKyB0LmNvbnRhaW5lclRvcCA/ICh0LnRyYW5zbGF0ZVkgPSBpIC0gdC5jb250YWluZXJUb3AsIG8gPSBcIlZJRVdQT1JULVRPUFwiKSA6IHQuY29udGFpbmVyQm90dG9tIDw9IG4gPyAodC50cmFuc2xhdGVZID0gdC5jb250YWluZXJCb3R0b20gLSBlLCBvID0gXCJDT05UQUlORVItQk9UVE9NXCIpIDogdGhpcy5pc1NpZGViYXJGaXRzVmlld3BvcnQoKSB8fCB0LmNvbnRhaW5lclRvcCA8PSBpICYmIDAgIT09IHQudHJhbnNsYXRlWSAmJiB0Lm1heFRyYW5zbGF0ZVkgIT09IHQudHJhbnNsYXRlWSAmJiAobyA9IFwiVklFV1BPUlQtVU5CT1RUT01cIiksIG99fSwge2tleTogXCJfZ2V0U3R5bGVcIiwgdmFsdWU6IGZ1bmN0aW9uICh0KSB7aWYgKHZvaWQgMCAhPT0gdCkge3ZhciBlID0ge2lubmVyOiB7fSwgb3V0ZXI6IHt9fSwgaSA9IHRoaXMuZGltZW5zaW9uczsgc3dpdGNoICh0KSB7Y2FzZSBcIlZJRVdQT1JULVRPUFwiOiBlLmlubmVyID0ge3Bvc2l0aW9uOiBcImZpeGVkXCIsIHRvcDogaS50b3BTcGFjaW5nLCBsZWZ0OiBpLnNpZGViYXJMZWZ0IC0gaS52aWV3cG9ydExlZnQsIHdpZHRoOiBpLnNpZGViYXJXaWR0aH07IGJyZWFrOyBjYXNlIFwiVklFV1BPUlQtQk9UVE9NXCI6IGUuaW5uZXIgPSB7cG9zaXRpb246IFwiZml4ZWRcIiwgdG9wOiBcImF1dG9cIiwgbGVmdDogaS5zaWRlYmFyTGVmdCwgYm90dG9tOiBpLmJvdHRvbVNwYWNpbmcsIHdpZHRoOiBpLnNpZGViYXJXaWR0aH07IGJyZWFrOyBjYXNlIFwiQ09OVEFJTkVSLUJPVFRPTVwiOiBjYXNlIFwiVklFV1BPUlQtVU5CT1RUT01cIjogdmFyIG4gPSB0aGlzLl9nZXRUcmFuc2xhdGUoMCwgaS50cmFuc2xhdGVZICsgXCJweFwiKTsgZS5pbm5lciA9IG4gPyB7dHJhbnNmb3JtOiBufSA6IHtwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB0b3A6IGkudHJhbnNsYXRlWSwgd2lkdGg6IGkuc2lkZWJhcldpZHRofX1zd2l0Y2ggKHQpIHtjYXNlIFwiVklFV1BPUlQtVE9QXCI6IGNhc2UgXCJWSUVXUE9SVC1CT1RUT01cIjogY2FzZSBcIlZJRVdQT1JULVVOQk9UVE9NXCI6IGNhc2UgXCJDT05UQUlORVItQk9UVE9NXCI6IGUub3V0ZXIgPSB7aGVpZ2h0OiBpLnNpZGViYXJIZWlnaHQsIHBvc2l0aW9uOiBcInJlbGF0aXZlXCJ9fXJldHVybiBlLm91dGVyID0gYy5leHRlbmQoe2hlaWdodDogXCJcIiwgcG9zaXRpb246IFwiXCJ9LCBlLm91dGVyKSwgZS5pbm5lciA9IGMuZXh0ZW5kKHtwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLCB0b3A6IFwiXCIsIGxlZnQ6IFwiXCIsIGJvdHRvbTogXCJcIiwgd2lkdGg6IFwiXCIsIHRyYW5zZm9ybTogXCJcIn0sIGUuaW5uZXIpLCBlfSB9fSwge2tleTogXCJzdGlja3lQb3NpdGlvblwiLCB2YWx1ZTogZnVuY3Rpb24gKHQpIHtpZiAoIXRoaXMuX2JyZWFrcG9pbnQpIHt0ID0gdGhpcy5fcmVTdHlsZSB8fCB0IHx8ICExLCB0aGlzLm9wdGlvbnMudG9wU3BhY2luZywgdGhpcy5vcHRpb25zLmJvdHRvbVNwYWNpbmc7IHZhciBlID0gdGhpcy5nZXRBZmZpeFR5cGUoKSwgaSA9IHRoaXMuX2dldFN0eWxlKGUpOyBpZiAoKHRoaXMuYWZmaXhlZFR5cGUgIT0gZSB8fCB0KSAmJiBlKSB7dmFyIG4gPSBcImFmZml4LlwiICsgZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoXCJ2aWV3cG9ydC1cIiwgXCJcIikgKyBsOyBmb3IgKHZhciBvIGluIGMuZXZlbnRUcmlnZ2VyKHRoaXMuc2lkZWJhciwgbiksIFwiU1RBVElDXCIgPT09IGUgPyBjLnJlbW92ZUNsYXNzKHRoaXMuc2lkZWJhciwgdGhpcy5vcHRpb25zLnN0aWNreUNsYXNzKSA6IGMuYWRkQ2xhc3ModGhpcy5zaWRlYmFyLCB0aGlzLm9wdGlvbnMuc3RpY2t5Q2xhc3MpLCBpLm91dGVyKSB7dmFyIHMgPSBcIm51bWJlclwiID09IHR5cGVvZiBpLm91dGVyW29dID8gXCJweFwiIDogXCJcIjsgdGhpcy5zaWRlYmFyLnN0eWxlW29dID0gaS5vdXRlcltvXSArIHN9IGZvciAodmFyIHIgaW4gaS5pbm5lcikge3ZhciBhID0gXCJudW1iZXJcIiA9PSB0eXBlb2YgaS5pbm5lcltyXSA/IFwicHhcIiA6IFwiXCI7IHRoaXMuc2lkZWJhcklubmVyLnN0eWxlW3JdID0gaS5pbm5lcltyXSArIGF9IHZhciBwID0gXCJhZmZpeGVkLlwiICsgZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoXCJ2aWV3cG9ydC1cIiwgXCJcIikgKyBsOyBjLmV2ZW50VHJpZ2dlcih0aGlzLnNpZGViYXIsIHApfSBlbHNlIHRoaXMuX2luaXRpYWxpemVkICYmICh0aGlzLnNpZGViYXJJbm5lci5zdHlsZS5sZWZ0ID0gaS5pbm5lci5sZWZ0KTsgdGhpcy5hZmZpeGVkVHlwZSA9IGV9IH19LCB7a2V5OiBcIl93aWR0aEJyZWFrcG9pbnRcIiwgdmFsdWU6IGZ1bmN0aW9uICgpIHt3aW5kb3cuaW5uZXJXaWR0aCA8PSB0aGlzLm9wdGlvbnMubWluV2lkdGggPyAodGhpcy5fYnJlYWtwb2ludCA9ICEwLCB0aGlzLmFmZml4ZWRUeXBlID0gXCJTVEFUSUNcIiwgdGhpcy5zaWRlYmFyLnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpLCBjLnJlbW92ZUNsYXNzKHRoaXMuc2lkZWJhciwgdGhpcy5vcHRpb25zLnN0aWNreUNsYXNzKSwgdGhpcy5zaWRlYmFySW5uZXIucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIikpIDogdGhpcy5fYnJlYWtwb2ludCA9ICExfX0sIHtrZXk6IFwidXBkYXRlU3RpY2t5XCIsIHZhbHVlOiBmdW5jdGlvbiAoKSB7dmFyIHQsIGUgPSB0aGlzLCBpID0gMCA8IGFyZ3VtZW50cy5sZW5ndGggJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMF0gPyBhcmd1bWVudHNbMF0gOiB7fTsgdGhpcy5fcnVubmluZyB8fCAodGhpcy5fcnVubmluZyA9ICEwLCB0ID0gaS50eXBlLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge3N3aXRjaCAodCkge2Nhc2UgXCJzY3JvbGxcIjogZS5fY2FsY0RpbWVuc2lvbnNXaXRoU2Nyb2xsKCksIGUub2JzZXJ2ZVNjcm9sbERpcigpLCBlLnN0aWNreVBvc2l0aW9uKCk7IGJyZWFrOyBjYXNlIFwicmVzaXplXCI6IGRlZmF1bHQ6IGUuX3dpZHRoQnJlYWtwb2ludCgpLCBlLmNhbGNEaW1lbnNpb25zKCksIGUuc3RpY2t5UG9zaXRpb24oITApfWUuX3J1bm5pbmcgPSAhMX0pKX19LCB7a2V5OiBcIl9zZXRTdXBwb3J0RmVhdHVyZXNcIiwgdmFsdWU6IGZ1bmN0aW9uICgpIHt2YXIgdCA9IHRoaXMuc3VwcG9ydDsgdC50cmFuc2Zvcm0gPSBjLnN1cHBvcnRUcmFuc2Zvcm0oKSwgdC50cmFuc2Zvcm0zZCA9IGMuc3VwcG9ydFRyYW5zZm9ybSghMCl9fSwge2tleTogXCJfZ2V0VHJhbnNsYXRlXCIsIHZhbHVlOiBmdW5jdGlvbiAoKSB7dmFyIHQgPSAwIDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1swXSA/IGFyZ3VtZW50c1swXSA6IDAsIGUgPSAxIDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1sxXSA/IGFyZ3VtZW50c1sxXSA6IDAsIGkgPSAyIDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6IDA7IHJldHVybiB0aGlzLnN1cHBvcnQudHJhbnNmb3JtM2QgPyBcInRyYW5zbGF0ZTNkKFwiICsgdCArIFwiLCBcIiArIGUgKyBcIiwgXCIgKyBpICsgXCIpXCIgOiAhIXRoaXMuc3VwcG9ydC50cmFuc2xhdGUgJiYgXCJ0cmFuc2xhdGUoXCIgKyB0ICsgXCIsIFwiICsgZSArIFwiKVwifX0sIHtrZXk6IFwiZGVzdHJveVwiLCB2YWx1ZTogZnVuY3Rpb24gKCkge3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMsIHtjYXB0dXJlOiAhMX0pLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLCB7Y2FwdHVyZTogITF9KSwgdGhpcy5zaWRlYmFyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5vcHRpb25zLnN0aWNreUNsYXNzKSwgdGhpcy5zaWRlYmFyLnN0eWxlLm1pbkhlaWdodCA9IFwiXCIsIHRoaXMuc2lkZWJhci5yZW1vdmVFdmVudExpc3RlbmVyKFwidXBkYXRlXCIgKyBsLCB0aGlzKTsgdmFyIHQgPSB7aW5uZXI6IHt9LCBvdXRlcjoge319OyBmb3IgKHZhciBlIGluIHQuaW5uZXIgPSB7cG9zaXRpb246IFwiXCIsIHRvcDogXCJcIiwgbGVmdDogXCJcIiwgYm90dG9tOiBcIlwiLCB3aWR0aDogXCJcIiwgdHJhbnNmb3JtOiBcIlwifSwgdC5vdXRlciA9IHtoZWlnaHQ6IFwiXCIsIHBvc2l0aW9uOiBcIlwifSwgdC5vdXRlcikgdGhpcy5zaWRlYmFyLnN0eWxlW2VdID0gdC5vdXRlcltlXTsgZm9yICh2YXIgaSBpbiB0LmlubmVyKSB0aGlzLnNpZGViYXJJbm5lci5zdHlsZVtpXSA9IHQuaW5uZXJbaV07IHRoaXMub3B0aW9ucy5yZXNpemVTZW5zb3IgJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgUmVzaXplU2Vuc29yICYmIChSZXNpemVTZW5zb3IuZGV0YWNoKHRoaXMuc2lkZWJhcklubmVyLCB0aGlzLmhhbmRsZUV2ZW50KSwgUmVzaXplU2Vuc29yLmRldGFjaCh0aGlzLmNvbnRhaW5lciwgdGhpcy5oYW5kbGVFdmVudCkpfX1dLCBbe2tleTogXCJzdXBwb3J0VHJhbnNmb3JtXCIsIHZhbHVlOiBmdW5jdGlvbiAodCkge3ZhciBpID0gITEsIGUgPSB0ID8gXCJwZXJzcGVjdGl2ZVwiIDogXCJ0cmFuc2Zvcm1cIiwgbiA9IGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBlLnNsaWNlKDEpLCBvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN1cHBvcnRcIikuc3R5bGU7IHJldHVybiAoZSArIFwiIFwiICsgW1wiV2Via2l0XCIsIFwiTW96XCIsIFwiT1wiLCBcIm1zXCJdLmpvaW4obiArIFwiIFwiKSArIG4pLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uICh0LCBlKSB7aWYgKHZvaWQgMCAhPT0gb1t0XSkgcmV0dXJuIGkgPSB0LCAhMX0pLCBpfX0sIHtrZXk6IFwiZXZlbnRUcmlnZ2VyXCIsIHZhbHVlOiBmdW5jdGlvbiAodCwgZSwgaSkge3RyeSB7dmFyIG4gPSBuZXcgQ3VzdG9tRXZlbnQoZSwge2RldGFpbDogaX0pfSBjYXRjaCAodCkgeyhuID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKSkuaW5pdEN1c3RvbUV2ZW50KGUsICEwLCAhMCwgaSl9IHQuZGlzcGF0Y2hFdmVudChuKX19LCB7a2V5OiBcImV4dGVuZFwiLCB2YWx1ZTogZnVuY3Rpb24gKHQsIGUpIHt2YXIgaSA9IHt9OyBmb3IgKHZhciBuIGluIHQpIHZvaWQgMCAhPT0gZVtuXSA/IGlbbl0gPSBlW25dIDogaVtuXSA9IHRbbl07IHJldHVybiBpfX0sIHtrZXk6IFwib2Zmc2V0UmVsYXRpdmVcIiwgdmFsdWU6IGZ1bmN0aW9uICh0KSB7dmFyIGUgPSB7bGVmdDogMCwgdG9wOiAwfTsgZG8ge3ZhciBpID0gdC5vZmZzZXRUb3AsIG4gPSB0Lm9mZnNldExlZnQ7IGlzTmFOKGkpIHx8IChlLnRvcCArPSBpKSwgaXNOYU4obikgfHwgKGUubGVmdCArPSBuKSwgdCA9IFwiQk9EWVwiID09PSB0LnRhZ05hbWUgPyB0LnBhcmVudEVsZW1lbnQgOiB0Lm9mZnNldFBhcmVudH0gd2hpbGUgKHQpOyByZXR1cm4gZX19LCB7a2V5OiBcImFkZENsYXNzXCIsIHZhbHVlOiBmdW5jdGlvbiAodCwgZSkge2MuaGFzQ2xhc3ModCwgZSkgfHwgKHQuY2xhc3NMaXN0ID8gdC5jbGFzc0xpc3QuYWRkKGUpIDogdC5jbGFzc05hbWUgKz0gXCIgXCIgKyBlKX19LCB7a2V5OiBcInJlbW92ZUNsYXNzXCIsIHZhbHVlOiBmdW5jdGlvbiAodCwgZSkge2MuaGFzQ2xhc3ModCwgZSkgJiYgKHQuY2xhc3NMaXN0ID8gdC5jbGFzc0xpc3QucmVtb3ZlKGUpIDogdC5jbGFzc05hbWUgPSB0LmNsYXNzTmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoXnxcXFxcYilcIiArIGUuc3BsaXQoXCIgXCIpLmpvaW4oXCJ8XCIpICsgXCIoXFxcXGJ8JClcIiwgXCJnaVwiKSwgXCIgXCIpKX19LCB7a2V5OiBcImhhc0NsYXNzXCIsIHZhbHVlOiBmdW5jdGlvbiAodCwgZSkge3JldHVybiB0LmNsYXNzTGlzdCA/IHQuY2xhc3NMaXN0LmNvbnRhaW5zKGUpIDogbmV3IFJlZ0V4cChcIihefCApXCIgKyBlICsgXCIoIHwkKVwiLCBcImdpXCIpLnRlc3QodC5jbGFzc05hbWUpfX0sIHtrZXk6IFwiZGVmYXVsdHNcIiwgZ2V0OiBmdW5jdGlvbiAoKSB7cmV0dXJuIG59fV0pLCBjfSgpKTsgdC5kZWZhdWx0ID0gaSwgd2luZG93LlN0aWNreVNpZGViYXIgPSBpfSkoZSl9KGUgPSB7ZXhwb3J0czoge319LCBlLmV4cG9ydHMpLCBlLmV4cG9ydHMpLCBvID0gKGkgPSBuKSAmJiBpLl9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGksIFwiZGVmYXVsdFwiKSA/IGkuZGVmYXVsdCA6IGk7IHQuZGVmYXVsdCA9IG8sIHQuX19tb2R1bGVFeHBvcnRzID0gbiwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6ICEwfSl9KTtcblxuaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5qcy1zdGlja3ktc2lkZWJhcicpKSB7XG4gICAgdmFyIHNpZGViYXIgPSBuZXcgU3RpY2t5U2lkZWJhcignLmpzLXN0aWNreS1zaWRlYmFyJywge1xuICAgICAgICB0b3BTcGFjaW5nOiAyMCxcbiAgICAgICAgYm90dG9tU3BhY2luZzogMjAsXG4gICAgICAgIGNvbnRhaW5lclNlbGVjdG9yOiAnLmpzLXN0aWNreS1tYWluLWNvbnRlbnQnLFxuICAgICAgICBpbm5lcldyYXBwZXJTZWxlY3RvcjogJy5qcy1zdGlja3ktc2lkZWJhcl9faW5uZXInLFxuICAgICAgICBtaW5XaWR0aDogMTAyNFxuICAgIH0pO1xufVxuIl19
